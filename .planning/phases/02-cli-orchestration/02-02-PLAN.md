---
phase: 02-cli-orchestration
plan: 02
type: execute
wave: 2
depends_on: ["02-01", "02-03"]
files_modified:
  - src/cli/index.ts
  - src/cli/commands/run.ts
  - bin/cli.js
  - package.json
autonomous: true

must_haves:
  truths:
    - "User can run `npx tsx src/cli/index.ts -t test -r /path/to/repo` and get a session result"
    - "Invalid arguments (missing --task-type, bad --turn-limit) produce clear errors and exit code 2"
    - "Session timeout exits with code 124"
    - "SIGINT (Ctrl+C) cleans up Docker container before exiting with code 130"
    - "Session result logged as structured JSON with metrics"
  artifacts:
    - path: "src/cli/index.ts"
      provides: "CLI entry point with Commander.js argument parsing"
      contains: "program.parse"
    - path: "src/cli/commands/run.ts"
      provides: "Run command handler wiring CLI to AgentSession"
      exports: ["runAgent"]
    - path: "bin/cli.js"
      provides: "ESM executable entry point with shebang"
      contains: "#!/usr/bin/env node"
    - path: "package.json"
      provides: "bin field and commander dependency"
      contains: "background-agent"
  key_links:
    - from: "src/cli/index.ts"
      to: "src/cli/commands/run.ts"
      via: "Commander action calls runAgent"
      pattern: "runAgent"
    - from: "src/cli/commands/run.ts"
      to: "src/orchestrator/session.ts"
      via: "Creates AgentSession, calls start/run/stop"
      pattern: "AgentSession"
    - from: "src/cli/commands/run.ts"
      to: "src/cli/utils/logger.ts"
      via: "Creates logger for session"
      pattern: "createLogger"
    - from: "src/cli/commands/run.ts"
      to: "src/orchestrator/metrics.ts"
      via: "Records session result in MetricsCollector"
      pattern: "MetricsCollector"
    - from: "bin/cli.js"
      to: "src/cli/index.ts"
      via: "ESM import (via dist)"
      pattern: "import.*dist/cli"
---

<objective>
Create the CLI entry point using Commander.js that wires all Phase 2 components together: argument parsing, session lifecycle, logging, metrics, and signal handling.

Purpose: This is the user-facing interface. Without it, there's no way to trigger agent runs. It brings together the logger (02-01), enhanced session (02-01), and metrics (02-03) into a usable CLI command.

Output: Working CLI command `background-agent -t <task-type> -r <repo-path>` that runs a complete agent session with safety limits and structured logging.
</objective>

<execution_context>
@/Users/kiruba/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kiruba/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-cli-orchestration/02-RESEARCH.md

# Prior plan outputs
@.planning/phases/02-cli-orchestration/02-01-SUMMARY.md
@.planning/phases/02-cli-orchestration/02-03-SUMMARY.md

@src/types.ts
@src/orchestrator/session.ts
@src/orchestrator/agent.ts
@src/orchestrator/metrics.ts
@src/orchestrator/container.ts
@src/orchestrator/index.ts
@src/cli/utils/logger.ts
@package.json
@tsconfig.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CLI entry point with Commander.js and run command</name>
  <files>
    src/cli/index.ts
    src/cli/commands/run.ts
    package.json
  </files>
  <action>
    **Step 1: Install commander and picocolors**
    ```
    npm install commander picocolors
    ```

    **Step 2: Create `src/cli/commands/run.ts`** -- the run command handler

    This is the core orchestration logic. It:

    1. Accepts validated options from Commander:
       ```typescript
       interface RunOptions {
         taskType: string;
         repo: string;
         turnLimit: number;    // already parsed and validated by CLI
         timeout: number;      // seconds, already parsed and validated
       }
       ```

    2. Creates a Pino logger using `createLogger()` from `src/cli/utils/logger.ts`

    3. Creates a child logger with `{ taskType, repo }` context

    4. Creates an `AgentSession` with:
       ```typescript
       const session = new AgentSession({
         workspaceDir: options.repo,
         turnLimit: options.turnLimit,
         timeoutMs: options.timeout * 1000,  // convert seconds to ms
       });
       ```

    5. Registers signal handlers for graceful cleanup:
       - `SIGINT`: Log "Received SIGINT, cleaning up...", call `session.stop()`, exit with code 130
       - `SIGTERM`: Log "Received SIGTERM, cleaning up...", call `session.stop()`, exit with code 143
       - Use `process.once()` not `process.on()` to prevent double-handling

    6. Runs the session lifecycle:
       ```
       await session.start()
       const result = await session.run(prompt, childLogger)
       ```
       Where `prompt` is constructed from taskType: `"You are a coding agent. Your task: ${options.taskType}. Work in the current directory."`

    7. Records metrics using MetricsCollector:
       ```typescript
       const metrics = new MetricsCollector();
       metrics.recordSession(result.status, result.turnCount, result.duration);
       ```

    8. Logs the session result and metrics as structured JSON

    9. Calls `session.stop()` in a `finally` block (always clean up)

    10. Returns the exit code based on result:
        - `'success'` -> 0
        - `'timeout'` -> 124
        - `'turn_limit'` -> 1
        - `'failed'` -> 1

    Export: `async function runAgent(options: RunOptions): Promise<number>` (returns exit code)

    **Step 3: Create `src/cli/index.ts`** -- Commander.js CLI entry point

    ```typescript
    import { Command } from 'commander';
    import pc from 'picocolors';
    import { runAgent } from './commands/run.js';

    const program = new Command();

    program
      .name('background-agent')
      .description('Run background coding agent in isolated Docker sandbox')
      .version('0.1.0')
      .requiredOption('-t, --task-type <type>', 'Task type (e.g., maven-dependency-update, npm-dependency-update)')
      .requiredOption('-r, --repo <path>', 'Target repository path (absolute or relative)')
      .option('--turn-limit <number>', 'Maximum agent turns (default: 10)', '10')
      .option('--timeout <seconds>', 'Session timeout in seconds (default: 300)', '300')
      .action(async (options) => {
        // Validate turn-limit
        const turnLimit = parseInt(options.turnLimit, 10);
        if (isNaN(turnLimit) || turnLimit < 1 || turnLimit > 100) {
          console.error(pc.red('Error: --turn-limit must be a number between 1 and 100'));
          process.exit(2);
        }

        // Validate timeout
        const timeout = parseInt(options.timeout, 10);
        if (isNaN(timeout) || timeout < 30 || timeout > 3600) {
          console.error(pc.red('Error: --timeout must be a number between 30 and 3600 seconds'));
          process.exit(2);
        }

        // Validate repo path exists (use fs.access)
        // If not, print error and exit with code 2

        const exitCode = await runAgent({
          taskType: options.taskType,
          repo: options.repo,
          turnLimit,
          timeout,
        });
        process.exit(exitCode);
      });

    program.parse();
    ```

    **Step 4: Update `package.json`**

    Add to package.json:
    - `"bin"` field: `{ "background-agent": "./bin/cli.js" }`
    - Add `"start:cli"` script: `"npx tsx src/cli/index.ts"`

    Do NOT modify existing scripts (test:agent, test:container, etc.).
  </action>
  <verify>
    - `npx tsc --noEmit` compiles without errors
    - `npx tsx src/cli/index.ts --help` shows usage with --task-type, --repo, --turn-limit, --timeout
    - `npx tsx src/cli/index.ts` without required args shows error and exits non-zero
    - `npx tsx src/cli/index.ts -t test -r /nonexistent --turn-limit -5` exits with code 2
  </verify>
  <done>
    CLI accepts --task-type and --repo (required), --turn-limit and --timeout (optional with defaults). Invalid args exit with code 2. Valid args create and run AgentSession with safety limits.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ESM executable entry point</name>
  <files>
    bin/cli.js
  </files>
  <action>
    Create directory `bin/` and file `bin/cli.js`:

    ```javascript
    #!/usr/bin/env node
    import '../dist/cli/index.js';
    ```

    This is the entry point for `npm link` / global install usage. It requires `npm run build` first (compiles TypeScript to dist/).

    Make the file executable: `chmod +x bin/cli.js`

    Note: During development, use `npx tsx src/cli/index.ts` directly (no build step needed). The bin/cli.js entry point is for production use after `npm run build`.
  </action>
  <verify>
    - `bin/cli.js` exists with shebang line
    - `ls -la bin/cli.js` shows executable permission
    - `npm run build` succeeds (TypeScript compiles)
    - `node bin/cli.js --help` shows CLI usage (after build)
  </verify>
  <done>
    ESM executable entry point exists at bin/cli.js. Works with `npm run build && node bin/cli.js --help`. Package.json bin field points to it.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- full project compiles
2. `npx tsx src/cli/index.ts --help` -- shows usage text
3. `npx tsx src/cli/index.ts -t test -r . --turn-limit 0` -- exits with code 2 (invalid turn limit)
4. `npx tsx src/cli/index.ts` -- exits non-zero (missing required args)
5. `npm run build && node bin/cli.js --help` -- built executable works
6. Signal handling: `npx tsx src/cli/index.ts -t test -r .` then Ctrl+C cleans up
</verification>

<success_criteria>
- CLI parses and validates --task-type, --repo, --turn-limit, --timeout
- Run command creates AgentSession with validated options
- Signal handlers clean up Docker containers on SIGINT/SIGTERM
- Session result logged as structured JSON with metrics
- POSIX exit codes: 0 (success), 1 (failure), 2 (invalid args), 124 (timeout), 130 (SIGINT)
- bin/cli.js works as ESM executable after build
</success_criteria>

<output>
After completion, create `.planning/phases/02-cli-orchestration/02-02-SUMMARY.md`
</output>
