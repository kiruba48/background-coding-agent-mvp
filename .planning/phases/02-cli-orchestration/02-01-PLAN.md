---
phase: 02-cli-orchestration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cli/utils/logger.ts
  - src/types.ts
  - src/orchestrator/session.ts
  - src/orchestrator/index.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Session enforces turn limit of 10 maximum and stops"
    - "Session enforces timeout of 5 minutes maximum and stops"
    - "Session state transitions through pending -> running -> success/failed"
    - "Structured JSON logs capture session lifecycle events"
    - "Sensitive fields (apiKey, token, password) are redacted in logs"
  artifacts:
    - path: "src/cli/utils/logger.ts"
      provides: "Pino-based structured JSON logger with redaction"
      exports: ["createLogger"]
    - path: "src/types.ts"
      provides: "SessionResult interface with state, turnCount, duration"
      contains: "SessionResult"
    - path: "src/orchestrator/session.ts"
      provides: "Enhanced AgentSession with turn limit, timeout, state tracking"
      contains: "turnLimit"
  key_links:
    - from: "src/orchestrator/session.ts"
      to: "src/cli/utils/logger.ts"
      via: "Logger injected into session for structured logging"
      pattern: "createLogger|pino"
    - from: "src/orchestrator/session.ts"
      to: "src/types.ts"
      via: "SessionResult returned from run()"
      pattern: "SessionResult"
---

<objective>
Add structured JSON logging with Pino and enhance AgentSession with turn limit enforcement, timeout enforcement, and session state tracking.

Purpose: These are the foundational pieces that the CLI command (Plan 02-02) will wire together. Without turn limits and timeouts, sessions can run forever. Without structured logging, debugging is impossible. Without state tracking, we can't report session outcomes.

Output: Logger utility, enhanced SessionState/SessionResult types, AgentSession that enforces safety limits and tracks state transitions.
</objective>

<execution_context>
@/Users/kiruba/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kiruba/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-cli-orchestration/02-RESEARCH.md

@src/types.ts
@src/orchestrator/session.ts
@src/orchestrator/agent.ts
@src/orchestrator/index.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Pino and create structured logger utility</name>
  <files>
    package.json
    src/cli/utils/logger.ts
  </files>
  <action>
    Install pino as a production dependency:
    ```
    npm install pino
    ```

    Create `src/cli/utils/logger.ts` with a `createLogger()` factory function:

    - Use pino with JSON output (no pino-pretty transport -- structured JSON to stdout is the goal)
    - Set default log level from `LOG_LEVEL` env var, fallback to 'info'
    - Configure redaction for sensitive fields: `apiKey`, `*.apiKey`, `token`, `*.token`, `password`, `*.password`, `env.ANTHROPIC_API_KEY`, `config.anthropicApiKey` -- censor as '[REDACTED]'
    - Export `createLogger` function that returns a pino Logger instance
    - Export the Logger type from pino for use in other modules

    The logger is a simple factory -- no classes, no singletons. Each consumer creates child loggers with `.child({ context })` for scoped logging.

    Do NOT install pino-pretty (development nicety, not needed for MVP).
  </action>
  <verify>
    - `npm ls pino` shows pino installed
    - `npx tsc --noEmit` compiles without errors
    - `src/cli/utils/logger.ts` exists with createLogger export
  </verify>
  <done>
    Pino logger factory exists with redaction config. Compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance session types and AgentSession with turn limit, timeout, and state tracking</name>
  <files>
    src/types.ts
    src/orchestrator/session.ts
    src/orchestrator/index.ts
  </files>
  <action>
    **Step 1: Enhance types in `src/types.ts`**

    Add a `SessionResult` interface:
    ```typescript
    export interface SessionResult {
      sessionId: string;
      status: 'success' | 'failed' | 'timeout' | 'turn_limit';
      turnCount: number;
      duration: number;      // milliseconds
      finalResponse: string; // Claude's final text response
      error?: string;        // Error message if failed
    }
    ```

    **Step 2: Enhance `SessionConfig` in `src/orchestrator/session.ts`**

    Add to the existing `SessionConfig` interface:
    ```typescript
    export interface SessionConfig {
      workspaceDir: string;
      image?: string;
      model?: string;
      turnLimit?: number;      // default: 10
      timeoutMs?: number;      // default: 300000 (5 minutes)
    }
    ```

    **Step 3: Enhance `AgentSession` in `src/orchestrator/session.ts`**

    Modify the `run()` method to:

    1. Accept a `pino.Logger` as an optional parameter (import Logger type from pino). If not provided, use a no-op fallback (create a pino logger with level 'silent').

    2. Generate a session ID using `crypto.randomUUID()` (from Node.js built-in).

    3. Track state transitions: log each transition (pending -> running -> success/failed/timeout/turn_limit).

    4. Enforce turn limit: Pass `this.config.turnLimit ?? 10` as `maxIterations` to `this.agent.runAgenticLoop()`. The agentic loop already enforces this -- the change is surfacing it as a config option and mapping its error to a proper SessionResult.

    5. Enforce timeout: Use `AbortController` with `setTimeout`. Wrap the `agent.runAgenticLoop()` call with `Promise.race` against the timeout. On timeout, call `this.container.cleanup()` in the finally block. The timeout default is `this.config.timeoutMs ?? 300000` (5 minutes).

    6. Return `SessionResult` instead of `string`:
       - On success: `{ sessionId, status: 'success', turnCount, duration, finalResponse }`
       - On timeout: `{ sessionId, status: 'timeout', turnCount, duration, finalResponse: '', error: 'Session timeout' }`
       - On turn limit: `{ sessionId, status: 'turn_limit', turnCount, duration, finalResponse: '', error: 'Turn limit exceeded' }`
       - On other errors: `{ sessionId, status: 'failed', turnCount, duration, finalResponse: '', error: message }`

    7. Log key events with the provided logger:
       - `logger.info({ sessionId, status: 'pending' }, 'Session created')`
       - `logger.info({ sessionId, status: 'running' }, 'Session started')`
       - `logger.info({ sessionId, status, turnCount, duration }, 'Session completed')`
       - `logger.error({ sessionId, err }, 'Session failed')`

    **Important:** The `run()` method signature changes from `run(userMessage: string): Promise<string>` to `run(userMessage: string, logger?: Logger): Promise<SessionResult>`. Import `SessionResult` from `../types.js`. Import `Logger` type from `pino`. If logger is not provided, create a silent pino instance: `import pino from 'pino'; const noopLogger = pino({ level: 'silent' });`

    **Step 4: Update exports in `src/orchestrator/index.ts`**

    Add `SessionResult` to the type exports (it's in types.ts so re-export from the orchestrator index for convenience).

    **Important constraints:**
    - Do NOT change the `start()` or `stop()` methods
    - Do NOT change the `executeTool()` method
    - Do NOT change the constructor signature (SessionConfig already existed, just adding optional fields)
    - The existing `AgentClient.runAgenticLoop()` already accepts `maxIterations` -- just pass the config value
    - Ensure backward compatibility: existing tests should still work since new fields are optional
  </action>
  <verify>
    - `npx tsc --noEmit` compiles without errors
    - `SessionResult` interface exists in `src/types.ts`
    - `SessionConfig` has `turnLimit` and `timeoutMs` optional fields
    - `AgentSession.run()` returns `Promise<SessionResult>`
    - `import { SessionResult } from '../types.js'` works in session.ts
  </verify>
  <done>
    AgentSession enforces configurable turn limit (default 10) and timeout (default 5 min). Returns SessionResult with status, turnCount, duration. Logs state transitions via injected Pino logger.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- full project compiles without errors
2. `src/cli/utils/logger.ts` exists and exports `createLogger`
3. `src/types.ts` contains `SessionResult` interface
4. `src/orchestrator/session.ts` has turn limit and timeout enforcement
5. Logger redaction configured for sensitive fields
</verification>

<success_criteria>
- Pino logger factory with JSON output and PII redaction is available
- AgentSession accepts turnLimit and timeoutMs config
- AgentSession.run() enforces both limits and returns SessionResult
- State transitions logged: pending -> running -> outcome
- All existing code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-cli-orchestration/02-01-SUMMARY.md`
</output>
