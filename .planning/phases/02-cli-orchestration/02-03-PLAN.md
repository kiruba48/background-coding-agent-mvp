---
phase: 02-cli-orchestration
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/orchestrator/metrics.ts
  - src/orchestrator/container.ts
  - src/orchestrator/index.ts
autonomous: true

must_haves:
  truths:
    - "Metrics collector tracks merge rate, veto rate, and time per session"
    - "Docker health check gives clear error when Docker daemon is not running"
    - "MetricsCollector.getMetrics() returns computed rates from recorded sessions"
  artifacts:
    - path: "src/orchestrator/metrics.ts"
      provides: "In-memory metrics collector for session outcomes"
      exports: ["MetricsCollector", "SessionMetrics"]
    - path: "src/orchestrator/container.ts"
      provides: "Docker daemon health check before container creation"
      contains: "checkHealth"
  key_links:
    - from: "src/orchestrator/metrics.ts"
      to: "src/types.ts"
      via: "Uses SessionResult status to categorize outcomes"
      pattern: "success|failed|vetoed"
    - from: "src/orchestrator/container.ts"
      to: "docker.ping"
      via: "Health check pings Docker daemon"
      pattern: "ping"
---

<objective>
Create an in-memory metrics collector for tracking session outcomes and add Docker daemon health check to ContainerManager.

Purpose: CLI-05 requires tracking merge rate, veto rate, cost per run, and time per session. The Docker health check prevents cryptic errors when Docker isn't running. Both are standalone components that the CLI command (Plan 02-02) will wire together.

Output: MetricsCollector class and ContainerManager.checkHealth() method.
</objective>

<execution_context>
@/Users/kiruba/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kiruba/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-cli-orchestration/02-RESEARCH.md

@src/types.ts
@src/orchestrator/container.ts
@src/orchestrator/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create in-memory MetricsCollector</name>
  <files>
    src/orchestrator/metrics.ts
    src/orchestrator/index.ts
  </files>
  <action>
    Create `src/orchestrator/metrics.ts` with:

    **SessionMetrics interface:**
    ```typescript
    export interface SessionMetrics {
      totalSessions: number;
      successCount: number;
      failureCount: number;
      vetoCount: number;
      timeoutCount: number;
      turnLimitCount: number;
      totalTurns: number;
      totalDurationMs: number;
    }

    export interface ComputedMetrics extends SessionMetrics {
      mergeRate: number;       // successCount / totalSessions (0-1)
      vetoRate: number;        // vetoCount / totalSessions (0-1)
      failureRate: number;     // failureCount / totalSessions (0-1)
      avgTurnsPerSession: number;
      avgDurationMs: number;   // average session duration
    }
    ```

    **MetricsCollector class:**
    ```typescript
    export class MetricsCollector {
      private metrics: SessionMetrics;

      constructor();

      // Record a completed session
      // status: 'success' | 'failed' | 'timeout' | 'turn_limit' | 'vetoed'
      // Increment the appropriate counter based on status
      // Always increment totalSessions, totalTurns, totalDurationMs
      recordSession(status: string, turnCount: number, durationMs: number): void;

      // Return raw + computed metrics
      // mergeRate = successCount / totalSessions (0 if no sessions)
      // vetoRate = vetoCount / totalSessions (0 if no sessions)
      // failureRate = failureCount / totalSessions (0 if no sessions)
      // avgTurnsPerSession = totalTurns / totalSessions (0 if no sessions)
      // avgDurationMs = totalDurationMs / totalSessions (0 if no sessions)
      getMetrics(): ComputedMetrics;

      // Reset all metrics to zero (useful for testing)
      reset(): void;
    }
    ```

    The MetricsCollector is intentionally simple -- in-memory, no persistence, no Prometheus. It tracks per-process metrics that are logged at session end. Persistence and export can be added later.

    Update `src/orchestrator/index.ts` to export `MetricsCollector`, `SessionMetrics`, and `ComputedMetrics`.
  </action>
  <verify>
    - `npx tsc --noEmit` compiles without errors
    - `src/orchestrator/metrics.ts` exists with MetricsCollector class
    - MetricsCollector has recordSession(), getMetrics(), reset() methods
  </verify>
  <done>
    MetricsCollector tracks session outcomes with computed merge rate, veto rate, failure rate, avg turns, and avg duration. Exported from orchestrator index.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Docker daemon health check to ContainerManager</name>
  <files>
    src/orchestrator/container.ts
  </files>
  <action>
    Add a `checkHealth()` method to the existing `ContainerManager` class in `src/orchestrator/container.ts`:

    ```typescript
    /**
     * Verify Docker daemon is running and accessible.
     * Call this before create() to provide a clear error message.
     *
     * @throws Error with actionable message if Docker is not available
     */
    async checkHealth(): Promise<void> {
      try {
        await this.docker.ping();
      } catch (error) {
        throw new Error(
          'Docker daemon is not running or not accessible. ' +
          'Please ensure Docker is installed and running. ' +
          'Try: docker ps'
        );
      }
    }
    ```

    Also call `this.checkHealth()` as the first line inside the existing `create()` method, before workspace validation. This ensures every container creation verifies Docker availability first.

    **Important constraints:**
    - Do NOT change any other methods (start, exec, stop, remove, cleanup)
    - Do NOT change the constructor
    - The checkHealth() call in create() should be the very first operation
    - Keep the existing error handling patterns (getErrorMessage helper)
  </action>
  <verify>
    - `npx tsc --noEmit` compiles without errors
    - `ContainerManager.checkHealth()` method exists
    - `create()` calls `checkHealth()` before workspace validation
  </verify>
  <done>
    Docker daemon health check runs automatically before container creation. Clear error message tells user to start Docker if it's not running.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- full project compiles without errors
2. `src/orchestrator/metrics.ts` exists with MetricsCollector
3. `src/orchestrator/container.ts` has checkHealth() method
4. MetricsCollector correctly computes rates from recorded sessions
</verification>

<success_criteria>
- MetricsCollector tracks all session outcome types and computes rates
- Docker health check provides clear error when daemon is unavailable
- Health check is automatically called before container creation
- All existing code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-cli-orchestration/02-03-SUMMARY.md`
</output>
