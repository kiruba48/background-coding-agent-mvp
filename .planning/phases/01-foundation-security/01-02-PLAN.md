---
phase: 01-foundation-security
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/orchestrator/container.ts
  - src/orchestrator/index.ts
autonomous: true

must_haves:
  truths:
    - "Container spawns with network mode none"
    - "Container uses non-root user from image"
    - "Workspace directory is bind-mounted at same path"
    - "Commands execute via docker exec and return output"
    - "Container stops gracefully on SIGTERM"
    - "Container is removed after session ends"
  artifacts:
    - path: "src/orchestrator/container.ts"
      provides: "Container lifecycle management"
      exports: ["ContainerManager"]
      min_lines: 100
    - path: "src/orchestrator/index.ts"
      provides: "Module exports"
      exports: ["ContainerManager"]
  key_links:
    - from: "src/orchestrator/container.ts"
      to: "/var/run/docker.sock"
      via: "dockerode client"
      pattern: "new Docker.*socketPath"
    - from: "src/orchestrator/container.ts"
      to: "docker exec"
      via: "container.exec()"
      pattern: "exec.*AttachStdout.*AttachStderr"
    - from: "src/orchestrator/container.ts"
      to: "demuxStream"
      via: "docker.modem.demuxStream"
      pattern: "demuxStream"
---

<objective>
Implement Docker container lifecycle management with security isolation using dockerode.

Purpose: Enable the orchestrator to create, manage, and tear down isolated containers where agent tools will execute. This is the security boundary between the AI agent and the host system.

Output: ContainerManager class that creates network-isolated containers, executes commands via docker exec with proper stream handling, and cleanly tears down containers.
</objective>

<execution_context>
@/Users/kiruba/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kiruba/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation-security/01-RESEARCH.md
@src/types.ts

Key patterns from research:
- Long-running container with `sleep infinity` CMD
- docker exec for each tool invocation (not ephemeral containers)
- demuxStream for stdout/stderr separation
- hijack: true for proper stream handling
- Bind mount workspace at SAME absolute path as host
- NetworkMode: 'none' for complete network isolation
- Graceful shutdown: SIGTERM first, then SIGKILL after timeout
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ContainerManager with full lifecycle</name>
  <files>
    src/orchestrator/container.ts
  </files>
  <action>
Create src/orchestrator/container.ts implementing:

1. **Constructor**: Initialize dockerode client with socket path

2. **create(config: ContainerConfig)**: Create container with:
   - Image: agent-sandbox:latest (or config.image)
   - User: 'agent:agent'
   - NetworkMode: 'none' (CRITICAL for security)
   - HostConfig with:
     - Memory limit (default 512MB)
     - NanoCpus limit (default 1 CPU = 1e9)
     - PidsLimit: 100
     - ReadonlyRootfs: true
     - Tmpfs: { '/tmp': 'rw,noexec,nosuid,size=100m' }
     - Binds: workspace at SAME absolute path
     - SecurityOpt: ['no-new-privileges:true']
     - CapDrop: ['ALL']
   - WorkingDir: absolute workspace path
   - Cmd: ['sh', '-c', 'sleep infinity']

3. **start()**: Start the container

4. **exec(command: string[])**: Execute command in running container
   - Use container.exec() with AttachStdout, AttachStderr: true
   - Start with hijack: true, stdin: false
   - Use docker.modem.demuxStream() to separate stdout/stderr
   - Collect output into buffers
   - Return { stdout, stderr, exitCode }

5. **stop(timeoutSeconds: number)**: Graceful shutdown
   - Send SIGTERM via container.stop({ t: timeoutSeconds })
   - Handle 304 (already stopped) gracefully
   - Force kill on timeout

6. **remove()**: Remove container
   - container.remove({ force: true })
   - Handle errors gracefully (already removed, etc.)

7. **cleanup()**: Combined stop + remove for convenience

Error handling:
- Wrap Docker API calls in try/catch
- Log meaningful error messages
- Re-throw with context for caller

Example structure:
```typescript
import Docker from 'dockerode';
import { ContainerConfig, ToolResult } from '../types.js';

export class ContainerManager {
  private docker: Docker;
  private container: Docker.Container | null = null;
  private workspaceDir: string = '';

  constructor(socketPath = '/var/run/docker.sock') {
    this.docker = new Docker({ socketPath });
  }

  async create(config: ContainerConfig): Promise<void> {
    const absWorkspace = path.resolve(config.workspaceDir);
    this.workspaceDir = absWorkspace;

    this.container = await this.docker.createContainer({
      Image: config.image,
      User: 'agent:agent',
      NetworkMode: 'none',
      HostConfig: {
        Memory: (config.memoryMB ?? 512) * 1024 * 1024,
        NanoCpus: (config.cpuCount ?? 1) * 1e9,
        PidsLimit: 100,
        ReadonlyRootfs: true,
        Tmpfs: { '/tmp': 'rw,noexec,nosuid,size=100m' },
        Binds: [`${absWorkspace}:${absWorkspace}:rw`],
        SecurityOpt: ['no-new-privileges:true'],
        CapDrop: ['ALL'],
      },
      WorkingDir: absWorkspace,
      Cmd: ['sh', '-c', 'sleep infinity'],
    });
  }

  async exec(command: string[]): Promise<ToolResult> {
    if (!this.container) throw new Error('Container not created');

    const exec = await this.container.exec({
      Cmd: command,
      AttachStdout: true,
      AttachStderr: true,
    });

    const stream = await exec.start({ hijack: true, stdin: false });

    let stdout = '';
    let stderr = '';

    await new Promise<void>((resolve, reject) => {
      this.docker.modem.demuxStream(
        stream,
        { write: (chunk: Buffer) => { stdout += chunk.toString(); } },
        { write: (chunk: Buffer) => { stderr += chunk.toString(); } }
      );
      stream.on('end', resolve);
      stream.on('error', reject);
    });

    const inspection = await exec.inspect();
    return {
      stdout,
      stderr,
      exitCode: inspection.ExitCode ?? 0,
    };
  }

  // ... stop, remove, cleanup methods
}
```
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - File exports ContainerManager class
    - Class has create, start, exec, stop, remove, cleanup methods
  </verify>
  <done>
    - ContainerManager creates containers with network isolation
    - exec() properly demuxes stdout/stderr
    - Graceful shutdown with SIGTERM -> SIGKILL fallback
    - Container removed on cleanup
  </done>
</task>

<task type="auto">
  <name>Task 2: Create integration test for container lifecycle</name>
  <files>
    src/orchestrator/container.test.ts
    src/orchestrator/index.ts
  </files>
  <action>
1. Create src/orchestrator/index.ts barrel export:
```typescript
export { ContainerManager } from './container.js';
```

2. Create src/orchestrator/container.test.ts with integration tests:

```typescript
import { ContainerManager } from './container.js';
import * as fs from 'fs/promises';
import * as path from 'path';
import * as os from 'os';

async function runTests() {
  console.log('=== Container Manager Integration Tests ===\n');

  // Create temp workspace
  const workspaceDir = await fs.mkdtemp(path.join(os.tmpdir(), 'agent-test-'));
  await fs.writeFile(path.join(workspaceDir, 'test.txt'), 'hello world');

  const manager = new ContainerManager();

  try {
    // Test 1: Create and start container
    console.log('Test 1: Create and start container...');
    await manager.create({
      image: 'agent-sandbox:latest',
      workspaceDir,
    });
    await manager.start();
    console.log('  ✓ Container created and started\n');

    // Test 2: Execute command and get output
    console.log('Test 2: Execute command...');
    const result = await manager.exec(['cat', 'test.txt']);
    if (result.stdout.trim() !== 'hello world') {
      throw new Error(`Expected 'hello world', got '${result.stdout}'`);
    }
    console.log('  ✓ Command output:', result.stdout.trim());
    console.log('  ✓ Exit code:', result.exitCode, '\n');

    // Test 3: Verify network isolation
    console.log('Test 3: Verify network isolation...');
    const pingResult = await manager.exec(['sh', '-c', 'ping -c 1 8.8.8.8 2>&1 || echo "network blocked"']);
    if (!pingResult.stdout.includes('network') && !pingResult.stderr.includes('network')) {
      console.log('  Warning: Network might not be fully isolated');
    } else {
      console.log('  ✓ Network access blocked as expected\n');
    }

    // Test 4: Verify non-root user
    console.log('Test 4: Verify non-root user...');
    const whoami = await manager.exec(['whoami']);
    if (whoami.stdout.trim() !== 'agent') {
      throw new Error(`Expected 'agent', got '${whoami.stdout}'`);
    }
    console.log('  ✓ Running as user:', whoami.stdout.trim(), '\n');

    // Test 5: Verify workspace mount
    console.log('Test 5: Verify workspace mount...');
    const pwd = await manager.exec(['pwd']);
    if (!pwd.stdout.includes(workspaceDir)) {
      throw new Error(`Workspace not mounted at expected path`);
    }
    console.log('  ✓ Workspace mounted at:', pwd.stdout.trim(), '\n');

    // Test 6: Write file and verify persistence on host
    console.log('Test 6: Verify file persistence...');
    await manager.exec(['sh', '-c', 'echo "from container" > created.txt']);
    const createdContent = await fs.readFile(path.join(workspaceDir, 'created.txt'), 'utf-8');
    if (createdContent.trim() !== 'from container') {
      throw new Error('File not persisted to host');
    }
    console.log('  ✓ Files persist to host filesystem\n');

    console.log('=== All tests passed! ===');

  } finally {
    // Cleanup
    console.log('\nCleaning up...');
    await manager.cleanup();
    await fs.rm(workspaceDir, { recursive: true });
    console.log('Done.');
  }
}

runTests().catch(err => {
  console.error('Test failed:', err);
  process.exit(1);
});
```

3. Add test script to package.json:
```json
"scripts": {
  "test:container": "npx tsx src/orchestrator/container.test.ts"
}
```

4. Run tests: `npm run test:container`
  </action>
  <verify>
    - `npm run test:container` passes all 6 tests
    - Container runs as non-root user
    - Network access is blocked
    - Files persist between container and host
  </verify>
  <done>
    - Integration tests verify container isolation
    - Tests verify non-root execution
    - Tests verify network isolation
    - Tests verify workspace mount and persistence
  </done>
</task>

</tasks>

<verification>
Run complete verification:

```bash
# Type check
npx tsc --noEmit

# Ensure Docker image exists
docker images | grep agent-sandbox

# Run integration tests
npm run test:container
```

Expected output from tests:
- Container created and started
- Commands execute and return correct output
- Network access blocked (ping fails)
- Running as user: agent
- Workspace mounted at correct path
- Files persist to host
</verification>

<success_criteria>
1. ContainerManager class implemented with all lifecycle methods
2. Containers created with NetworkMode: 'none'
3. exec() properly separates stdout/stderr via demuxStream
4. Integration tests pass, proving:
   - Container runs as non-root user
   - Network is isolated
   - Workspace is mounted and writable
   - Files persist to host
5. TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-security/01-02-SUMMARY.md`
</output>
