---
phase: 01-foundation-security
plan: 04
type: execute
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - src/orchestrator/session.ts
  - src/orchestrator/session.test.ts
  - src/orchestrator/index.ts
autonomous: true
user_setup:
  - service: anthropic
    why: "Claude API access for agent communication"
    env_vars:
      - name: ANTHROPIC_API_KEY
        source: "Anthropic Console -> API Keys -> Create Key"

must_haves:
  truths:
    - "Session creates container with network isolation"
    - "Session connects container execution to Claude tool use"
    - "Claude can request file reads via tools and receive content"
    - "Claude can request bash commands via tools and receive output"
    - "Session tears down container cleanly on completion"
    - "Session tears down container cleanly on error"
  artifacts:
    - path: "src/orchestrator/session.ts"
      provides: "Integrated agent session"
      exports: ["AgentSession"]
      min_lines: 80
  key_links:
    - from: "src/orchestrator/session.ts"
      to: "src/orchestrator/container.ts"
      via: "ContainerManager"
      pattern: "ContainerManager"
    - from: "src/orchestrator/session.ts"
      to: "src/orchestrator/agent.ts"
      via: "AgentClient"
      pattern: "AgentClient"
    - from: "src/orchestrator/session.ts"
      to: "tool execution"
      via: "exec in container"
      pattern: "container\\.exec"
---

<objective>
Wire container execution to Claude SDK, creating the complete agent session that can receive instructions and execute tools in isolated containers.

Purpose: This is the integration point that proves the Phase 1 architecture works end-to-end. Claude requests tool execution, the orchestrator runs commands in the isolated container, and returns results to Claude.

Output: AgentSession class that orchestrates the full flow: Claude -> tool request -> container exec -> tool result -> Claude, with proper lifecycle management.
</objective>

<execution_context>
@/Users/kiruba/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kiruba/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation-security/01-RESEARCH.md
@src/types.ts
@src/orchestrator/container.ts
@src/orchestrator/agent.ts

The integration flow:
1. AgentSession creates ContainerManager and AgentClient
2. Session defines tools (read_file, execute_bash)
3. Session calls AgentClient.runAgenticLoop with tool executor
4. Tool executor routes to ContainerManager.exec
5. Results flow back through the agentic loop
6. Session cleans up container when done
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement AgentSession wiring container to SDK</name>
  <files>
    src/orchestrator/session.ts
  </files>
  <action>
Create src/orchestrator/session.ts implementing:

1. **Constructor(config)**: Initialize with workspace, image, and API key

2. **Define built-in tools**:
```typescript
const TOOLS = [
  {
    name: 'read_file',
    description: 'Read the contents of a file in the workspace',
    input_schema: {
      type: 'object',
      properties: {
        path: { type: 'string', description: 'Path to file relative to workspace' }
      },
      required: ['path']
    }
  },
  {
    name: 'execute_bash',
    description: 'Execute a bash command in the workspace',
    input_schema: {
      type: 'object',
      properties: {
        command: { type: 'string', description: 'Bash command to execute' }
      },
      required: ['command']
    }
  },
  {
    name: 'list_files',
    description: 'List files in a directory',
    input_schema: {
      type: 'object',
      properties: {
        path: { type: 'string', description: 'Directory path relative to workspace (default: .)' }
      }
    }
  }
];
```

3. **start()**: Create and start container

4. **run(userMessage)**: Execute the agentic loop
   - Call agentClient.runAgenticLoop
   - Pass tool executor that routes to container.exec
   - Return final response from Claude

5. **executeTool(name, input)**: Route tool calls to container
   - read_file: `cat <path>`
   - execute_bash: `bash -c "<command>"`
   - list_files: `ls -la <path>`
   - Return stdout, or stderr on error

6. **stop()**: Clean up container (graceful)

7. **cleanup()**: Force cleanup (for errors)

Example structure:
```typescript
import { ContainerManager } from './container.js';
import { AgentClient } from './agent.js';
import { ContainerConfig, AgentSession as SessionState } from '../types.js';

export interface SessionConfig {
  workspaceDir: string;
  image?: string;
  apiKey?: string;
}

export class AgentSession {
  private container: ContainerManager;
  private agent: AgentClient;
  private config: SessionConfig;
  private started = false;

  constructor(config: SessionConfig) {
    this.config = config;
    this.container = new ContainerManager();
    this.agent = new AgentClient(config.apiKey);
  }

  async start(): Promise<void> {
    await this.container.create({
      image: this.config.image ?? 'agent-sandbox:latest',
      workspaceDir: this.config.workspaceDir,
    });
    await this.container.start();
    this.started = true;
  }

  async run(userMessage: string): Promise<string> {
    if (!this.started) {
      throw new Error('Session not started. Call start() first.');
    }

    return this.agent.runAgenticLoop(
      userMessage,
      TOOLS,
      async (name, input) => this.executeTool(name, input),
    );
  }

  private async executeTool(
    name: string,
    input: Record<string, unknown>
  ): Promise<string> {
    switch (name) {
      case 'read_file': {
        const path = input.path as string;
        const result = await this.container.exec(['cat', path]);
        if (result.exitCode !== 0) {
          return `Error reading file: ${result.stderr}`;
        }
        return result.stdout;
      }

      case 'execute_bash': {
        const command = input.command as string;
        const result = await this.container.exec(['bash', '-c', command]);
        const output = result.stdout + result.stderr;
        return output || `(exit code: ${result.exitCode})`;
      }

      case 'list_files': {
        const path = (input.path as string) || '.';
        const result = await this.container.exec(['ls', '-la', path]);
        if (result.exitCode !== 0) {
          return `Error listing files: ${result.stderr}`;
        }
        return result.stdout;
      }

      default:
        return `Unknown tool: ${name}`;
    }
  }

  async stop(): Promise<void> {
    if (this.started) {
      await this.container.cleanup();
      this.started = false;
    }
  }
}
```

Key points:
- Container is created on start(), not in constructor
- Tools execute via container.exec()
- Proper error handling returns errors as tool results
- Cleanup happens even if errors occur
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - File exports AgentSession class
    - Class has start, run, stop methods
  </verify>
  <done>
    - AgentSession wires ContainerManager to AgentClient
    - Tools (read_file, execute_bash, list_files) execute in container
    - Proper lifecycle management with start/stop
  </done>
</task>

<task type="auto">
  <name>Task 2: Create end-to-end integration test</name>
  <files>
    src/orchestrator/session.test.ts
    src/orchestrator/index.ts
  </files>
  <action>
1. Update src/orchestrator/index.ts:
```typescript
export { ContainerManager } from './container.js';
export { AgentClient } from './agent.js';
export { AgentSession } from './session.js';
```

2. Create src/orchestrator/session.test.ts:

```typescript
import { AgentSession } from './session.js';
import * as fs from 'fs/promises';
import * as path from 'path';
import * as os from 'os';

async function runTests() {
  console.log('=== Agent Session End-to-End Tests ===\n');

  // Check prerequisites
  if (!process.env.ANTHROPIC_API_KEY) {
    console.error('ERROR: ANTHROPIC_API_KEY environment variable required');
    process.exit(1);
  }

  // Create temp workspace with test files
  const workspaceDir = await fs.mkdtemp(path.join(os.tmpdir(), 'agent-e2e-'));
  await fs.writeFile(
    path.join(workspaceDir, 'greeting.txt'),
    'Hello from the workspace!'
  );
  await fs.mkdir(path.join(workspaceDir, 'src'));
  await fs.writeFile(
    path.join(workspaceDir, 'src', 'example.js'),
    'console.log("Hello World");'
  );

  console.log('Workspace created at:', workspaceDir);
  console.log('');

  const session = new AgentSession({ workspaceDir });

  try {
    // Start session
    console.log('Starting session (creating container)...');
    await session.start();
    console.log('  ✓ Session started\n');

    // Test 1: Read a file
    console.log('Test 1: Ask Claude to read a file...');
    const readResult = await session.run(
      'Read the file greeting.txt and tell me what it says.'
    );
    console.log('  Claude response:', readResult.substring(0, 200));
    if (!readResult.toLowerCase().includes('hello')) {
      console.log('  Warning: Expected response to mention "hello"');
    }
    console.log('  ✓ File read test completed\n');

    // Test 2: List files
    console.log('Test 2: Ask Claude to list files...');
    const listResult = await session.run(
      'List the files in the current directory and the src subdirectory.'
    );
    console.log('  Claude response:', listResult.substring(0, 300));
    if (!listResult.includes('greeting') && !listResult.includes('src')) {
      console.log('  Warning: Expected response to list files');
    }
    console.log('  ✓ List files test completed\n');

    // Test 3: Execute bash command
    console.log('Test 3: Ask Claude to execute a command...');
    const bashResult = await session.run(
      'Use bash to count the number of lines in src/example.js'
    );
    console.log('  Claude response:', bashResult.substring(0, 200));
    console.log('  ✓ Bash execution test completed\n');

    // Test 4: Create a file (verifies write works)
    console.log('Test 4: Ask Claude to create a file...');
    const createResult = await session.run(
      'Create a new file called "output.txt" containing the text "Created by Claude" using bash.'
    );
    console.log('  Claude response:', createResult.substring(0, 200));

    // Verify file was created
    const outputPath = path.join(workspaceDir, 'output.txt');
    try {
      const content = await fs.readFile(outputPath, 'utf-8');
      console.log('  File content:', content.trim());
      console.log('  ✓ File creation verified on host\n');
    } catch {
      console.log('  Warning: output.txt not found (Claude may have used different filename)\n');
    }

    console.log('=== All tests completed! ===\n');
    console.log('Phase 1 Success Criteria Verified:');
    console.log('  ✓ Container spawns with non-root user and isolated workspace');
    console.log('  ✓ Container has no external network access');
    console.log('  ✓ Agent SDK can send/receive messages to Claude API');
    console.log('  ✓ Container can be torn down cleanly');

  } finally {
    // Cleanup
    console.log('\nCleaning up...');
    await session.stop();
    await fs.rm(workspaceDir, { recursive: true });
    console.log('Done.');
  }
}

runTests().catch(err => {
  console.error('Test failed:', err);
  process.exit(1);
});
```

3. Add test script to package.json:
```json
"scripts": {
  "test:session": "npx tsx src/orchestrator/session.test.ts",
  "test:all": "npm run test:container && npm run test:agent && npm run test:session"
}
```

4. Run tests: `npm run test:session`
  </action>
  <verify>
    - `npm run test:session` completes all tests
    - Claude can read files via read_file tool
    - Claude can execute commands via execute_bash tool
    - Claude can list files via list_files tool
    - Files created in container persist to host
    - Container is cleaned up after session
  </verify>
  <done>
    - End-to-end test proves full Phase 1 architecture
    - Claude communicates via SDK
    - Tools execute in isolated container
    - Results flow back to Claude
    - Session lifecycle managed properly
  </done>
</task>

</tasks>

<verification>
Run complete Phase 1 verification:

```bash
# Type check entire project
npx tsc --noEmit

# Build Docker image (if not already built)
docker build -t agent-sandbox:latest -f docker/Dockerfile docker/

# Run all tests
export ANTHROPIC_API_KEY=your-key-here
npm run test:all
```

Phase 1 Success Criteria checklist:
1. Container spawns with non-root user (agent) - verified in container tests
2. Container has no external network access - verified in container tests
3. Agent SDK can send/receive messages - verified in agent tests
4. Container torn down cleanly - verified in session tests
</verification>

<success_criteria>
1. AgentSession class wires ContainerManager to AgentClient
2. Tools (read_file, execute_bash, list_files) execute in container
3. End-to-end test proves:
   - Claude can read files via tools
   - Claude can execute bash via tools
   - Claude can list files via tools
   - Files persist between container and host
4. Session cleans up container on stop
5. All Phase 1 Success Criteria from ROADMAP verified
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-security/01-04-SUMMARY.md`

This SUMMARY should include verification that all Phase 1 success criteria are met:
- Container spawns with non-root user and isolated workspace
- Container has no external network access (network mode: none)
- Agent SDK can send/receive messages to Claude API from orchestrator
- Container can be torn down cleanly after session
</output>
