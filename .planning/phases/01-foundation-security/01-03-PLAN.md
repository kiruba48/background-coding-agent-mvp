---
phase: 01-foundation-security
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/orchestrator/agent.ts
  - src/orchestrator/index.ts
autonomous: true
user_setup:
  - service: anthropic
    why: "Claude API access for agent communication"
    env_vars:
      - name: ANTHROPIC_API_KEY
        source: "Anthropic Console -> API Keys -> Create Key"

must_haves:
  truths:
    - "SDK connects to Anthropic API with valid key"
    - "Streaming responses arrive in real-time"
    - "Tool definitions can be provided to Claude"
    - "Tool use responses are parsed correctly"
    - "Error responses are handled gracefully"
  artifacts:
    - path: "src/orchestrator/agent.ts"
      provides: "Anthropic SDK integration"
      exports: ["AgentClient"]
      min_lines: 80
  key_links:
    - from: "src/orchestrator/agent.ts"
      to: "Anthropic API"
      via: "@anthropic-ai/sdk"
      pattern: "new Anthropic.*apiKey"
    - from: "src/orchestrator/agent.ts"
      to: "messages.create"
      via: "agentic loop"
      pattern: "stop_reason.*tool_use"
---

<objective>
Implement Anthropic SDK integration for Claude communication with streaming and tool use support.

Purpose: Enable the orchestrator to communicate with Claude via the Messages API, handling streaming responses and the tool use agentic loop pattern. This is how the AI agent receives instructions and requests tool execution.

Output: AgentClient class that sends messages to Claude, streams responses, handles tool_use stop_reason, and manages conversation state for the agentic loop.
</objective>

<execution_context>
@/Users/kiruba/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kiruba/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation-security/01-RESEARCH.md
@src/types.ts

Key patterns from research:
- Use @anthropic-ai/sdk with streaming helpers
- Tool use agentic loop: message -> tool_use -> tool_result -> continue
- stop_reason: 'tool_use' means execute tools and continue
- stop_reason: 'end_turn' means Claude is done
- Tool results sent as { type: 'tool_result', tool_use_id, content }
- Handle overloaded_error (529) with retry
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement AgentClient with streaming and tool use</name>
  <files>
    src/orchestrator/agent.ts
  </files>
  <action>
Create src/orchestrator/agent.ts implementing:

1. **Constructor**: Initialize Anthropic client with API key from env

2. **Types for tool handling**:
```typescript
interface Tool {
  name: string;
  description: string;
  input_schema: {
    type: 'object';
    properties: Record<string, unknown>;
    required?: string[];
  };
}

interface ToolCall {
  id: string;
  name: string;
  input: Record<string, unknown>;
}

interface ToolResultInput {
  tool_use_id: string;
  content: string;
  is_error?: boolean;
}
```

3. **streamMessage(messages, tools, onText)**: Stream a single message
   - Call anthropic.messages.stream()
   - Wire onText callback to 'text' event
   - Return final message with stop_reason
   - Handle errors appropriately

4. **extractToolCalls(message)**: Parse tool_use blocks from response
   - Filter content blocks where type === 'tool_use'
   - Return array of { id, name, input }

5. **createToolResultMessage(results)**: Format tool results for API
   - Create user message with tool_result content blocks
   - Each result: { type: 'tool_result', tool_use_id, content, is_error? }

6. **runAgenticLoop(userMessage, tools, executeTool, onText?)**: Full loop
   - Initialize messages array with user message
   - Loop:
     - Send message with tools
     - Add assistant response to messages
     - If stop_reason === 'end_turn', return final text
     - If stop_reason === 'tool_use':
       - Extract tool calls
       - Execute each via executeTool callback
       - Add tool results to messages
       - Continue loop
   - Handle max iterations (prevent infinite loops)

Error handling:
- Check for ANTHROPIC_API_KEY in constructor
- Handle rate limits (429) with exponential backoff
- Handle overload (529) with retry
- Wrap API errors with meaningful messages

Example structure:
```typescript
import Anthropic from '@anthropic-ai/sdk';

export class AgentClient {
  private client: Anthropic;
  private model = 'claude-sonnet-4-5-20250929';

  constructor(apiKey?: string) {
    const key = apiKey ?? process.env.ANTHROPIC_API_KEY;
    if (!key) {
      throw new Error('ANTHROPIC_API_KEY required');
    }
    this.client = new Anthropic({ apiKey: key });
  }

  async runAgenticLoop(
    userMessage: string,
    tools: Tool[],
    executeTool: (name: string, input: Record<string, unknown>) => Promise<string>,
    onText?: (text: string) => void,
    maxIterations = 10
  ): Promise<string> {
    const messages: Anthropic.MessageParam[] = [
      { role: 'user', content: userMessage }
    ];

    for (let i = 0; i < maxIterations; i++) {
      const response = await this.client.messages.create({
        model: this.model,
        max_tokens: 4096,
        tools: tools as Anthropic.Tool[],
        messages,
      });

      // Add assistant response to conversation
      messages.push({
        role: 'assistant',
        content: response.content,
      });

      // Handle stop reason
      if (response.stop_reason === 'end_turn') {
        const textBlock = response.content.find(b => b.type === 'text');
        return textBlock?.text ?? '';
      }

      if (response.stop_reason === 'tool_use') {
        const toolResults: Anthropic.ToolResultBlockParam[] = [];

        for (const block of response.content) {
          if (block.type === 'tool_use') {
            try {
              const result = await executeTool(block.name, block.input as Record<string, unknown>);
              toolResults.push({
                type: 'tool_result',
                tool_use_id: block.id,
                content: result,
              });
            } catch (err) {
              toolResults.push({
                type: 'tool_result',
                tool_use_id: block.id,
                content: `Error: ${err instanceof Error ? err.message : String(err)}`,
                is_error: true,
              });
            }
          }
        }

        messages.push({
          role: 'user',
          content: toolResults,
        });

        continue;
      }

      throw new Error(`Unexpected stop_reason: ${response.stop_reason}`);
    }

    throw new Error(`Max iterations (${maxIterations}) exceeded`);
  }
}
```
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - File exports AgentClient class
    - Class has runAgenticLoop method
    - Constructor validates API key
  </verify>
  <done>
    - AgentClient connects to Anthropic API
    - runAgenticLoop handles tool_use -> tool_result flow
    - Error handling for missing API key
    - Max iterations prevent infinite loops
  </done>
</task>

<task type="auto">
  <name>Task 2: Create integration test for SDK communication</name>
  <files>
    src/orchestrator/agent.test.ts
    src/orchestrator/index.ts
  </files>
  <action>
1. Update src/orchestrator/index.ts to export AgentClient:
```typescript
export { ContainerManager } from './container.js';
export { AgentClient } from './agent.js';
```

2. Create src/orchestrator/agent.test.ts:

```typescript
import { AgentClient } from './agent.js';

async function runTests() {
  console.log('=== Agent Client Integration Tests ===\n');

  // Check API key
  if (!process.env.ANTHROPIC_API_KEY) {
    console.error('ERROR: ANTHROPIC_API_KEY environment variable required');
    console.error('Set it with: export ANTHROPIC_API_KEY=your-key');
    process.exit(1);
  }

  const client = new AgentClient();

  // Test 1: Simple message (no tools)
  console.log('Test 1: Simple message without tools...');
  const simpleResult = await client.runAgenticLoop(
    'What is 2 + 2? Reply with just the number.',
    [],
    async () => '',
  );
  console.log('  Response:', simpleResult.trim());
  if (!simpleResult.includes('4')) {
    console.log('  Warning: Expected response to contain "4"');
  }
  console.log('  ✓ Simple message completed\n');

  // Test 2: Tool use flow
  console.log('Test 2: Tool use flow...');
  const calculatorTool = {
    name: 'calculate',
    description: 'Performs arithmetic calculation',
    input_schema: {
      type: 'object' as const,
      properties: {
        expression: { type: 'string', description: 'Math expression like "2 + 2"' }
      },
      required: ['expression']
    }
  };

  let toolCalled = false;
  const toolResult = await client.runAgenticLoop(
    'Use the calculate tool to compute 15 * 7, then tell me the result.',
    [calculatorTool],
    async (name, input) => {
      console.log(`  Tool called: ${name}(${JSON.stringify(input)})`);
      toolCalled = true;
      if (name === 'calculate') {
        // Simple eval for demo (in real code, use proper parsing)
        const expr = (input as { expression: string }).expression;
        try {
          // Safe eval for simple arithmetic
          const result = Function(`"use strict"; return (${expr})`)();
          return String(result);
        } catch {
          return 'Error: Invalid expression';
        }
      }
      return 'Unknown tool';
    }
  );

  if (!toolCalled) {
    throw new Error('Expected calculate tool to be called');
  }
  console.log('  ✓ Tool was called');
  console.log('  Final response:', toolResult.substring(0, 100));
  if (!toolResult.includes('105')) {
    console.log('  Warning: Expected response to contain "105"');
  }
  console.log('  ✓ Tool use flow completed\n');

  // Test 3: Error handling in tools
  console.log('Test 3: Tool error handling...');
  const errorTool = {
    name: 'failing_tool',
    description: 'A tool that always fails',
    input_schema: {
      type: 'object' as const,
      properties: {},
    }
  };

  const errorResult = await client.runAgenticLoop(
    'Call the failing_tool and tell me what happened.',
    [errorTool],
    async () => {
      throw new Error('Intentional test failure');
    }
  );
  console.log('  Response:', errorResult.substring(0, 150));
  console.log('  ✓ Error handled gracefully\n');

  console.log('=== All tests passed! ===');
}

runTests().catch(err => {
  console.error('Test failed:', err);
  process.exit(1);
});
```

3. Add test script to package.json:
```json
"scripts": {
  "test:agent": "npx tsx src/orchestrator/agent.test.ts"
}
```

4. Run tests (requires ANTHROPIC_API_KEY): `npm run test:agent`
  </action>
  <verify>
    - `npm run test:agent` passes all 3 tests (requires valid API key)
    - Tool use flow correctly calls executeTool callback
    - Tool errors are handled and reported to Claude
  </verify>
  <done>
    - Integration tests verify API connectivity
    - Tests verify tool use flow works
    - Tests verify error handling in tools
  </done>
</task>

</tasks>

<verification>
Run complete verification:

```bash
# Type check
npx tsc --noEmit

# Run SDK tests (requires ANTHROPIC_API_KEY)
export ANTHROPIC_API_KEY=your-key-here
npm run test:agent
```

Expected output:
- Simple message returns response
- Tool use flow calls tool and gets result
- Tool errors handled gracefully
</verification>

<success_criteria>
1. AgentClient class implemented with runAgenticLoop method
2. Tool use agentic loop correctly processes tool_use/tool_result cycle
3. Error handling for missing API key, tool errors, max iterations
4. Integration tests pass with valid API key
5. TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-security/01-03-SUMMARY.md`
</output>
