---
phase: 04-retry-context-engineering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types.ts
  - src/orchestrator/summarizer.ts
  - src/orchestrator/retry.ts
autonomous: true
requirements:
  - EXEC-05
  - EXEC-06

must_haves:
  truths:
    - "RetryOrchestrator starts fresh AgentSession per attempt (never reuses conversation)"
    - "Verification errors are summarized to under 500 tokens before being sent to agent"
    - "Retry counter enforces max 3 retries and terminates cleanly when exhausted"
    - "Session-level failures (timeout, turn_limit) are NOT retried"
    - "Original task is always included first in retry messages"
  artifacts:
    - path: "src/types.ts"
      provides: "VerificationError, VerificationResult, RetryConfig, RetryResult types"
      contains: "VerificationResult"
    - path: "src/orchestrator/summarizer.ts"
      provides: "ErrorSummarizer with build, test, lint summarization + digest builder"
      exports: ["ErrorSummarizer"]
    - path: "src/orchestrator/retry.ts"
      provides: "RetryOrchestrator wrapping AgentSession in outer retry loop"
      exports: ["RetryOrchestrator"]
  key_links:
    - from: "src/orchestrator/retry.ts"
      to: "src/orchestrator/session.ts"
      via: "Creates new AgentSession per retry attempt"
      pattern: "new AgentSession"
    - from: "src/orchestrator/retry.ts"
      to: "src/orchestrator/summarizer.ts"
      via: "ErrorSummarizer.buildDigest for retry messages"
      pattern: "ErrorSummarizer\\.buildDigest"
    - from: "src/orchestrator/retry.ts"
      to: "src/types.ts"
      via: "Uses VerificationResult and RetryResult types"
      pattern: "VerificationResult.*RetryResult"
---

<objective>
Implement the retry orchestration layer and error summarization engine for Phase 4.

Purpose: Enable the agent to recover from verification failures by starting fresh sessions with actionable error context. This is the outer retry loop that wraps AgentSession — distinct from the API-level retry already in agent.ts.

Output: RetryOrchestrator class, ErrorSummarizer class, and verification/retry type definitions.
</objective>

<execution_context>
@/Users/kiruba/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kiruba/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-retry-context-engineering/04-RESEARCH.md

@src/types.ts
@src/orchestrator/session.ts
@src/orchestrator/metrics.ts
@src/orchestrator/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add verification/retry types and create ErrorSummarizer</name>
  <files>
    src/types.ts
    src/orchestrator/summarizer.ts
  </files>
  <action>
**In `src/types.ts`**, append the following new type definitions AFTER the existing `SessionResult` interface:

```typescript
/**
 * A single verification error from a verifier (build, test, lint, or custom).
 * Phase 5 verifiers will produce these; Phase 4 defines the interface.
 */
export interface VerificationError {
  type: 'build' | 'test' | 'lint' | 'custom';
  summary: string;       // LLM-digestible 1-line summary, max ~100 chars
  rawOutput?: string;    // Full output for logging only, NOT sent to LLM
}

/**
 * Result from running verification on a workspace after agent session.
 */
export interface VerificationResult {
  passed: boolean;
  errors: VerificationError[];
  durationMs: number;
}

/**
 * Configuration for retry orchestration.
 */
export interface RetryConfig {
  maxRetries: number;  // default: 3
  verifier?: (workspaceDir: string) => Promise<VerificationResult>;
}

/**
 * Result from a full retry-orchestrated run (may include multiple session attempts).
 */
export interface RetryResult {
  finalStatus: 'success' | 'failed' | 'timeout' | 'turn_limit' | 'max_retries_exhausted';
  attempts: number;           // 1-indexed, always >= 1
  sessionResults: SessionResult[];
  verificationResults: VerificationResult[];
  error?: string;
}
```

**Create `src/orchestrator/summarizer.ts`** with the ErrorSummarizer class:

- `static summarizeBuildErrors(rawOutput: string): string` — Extract TypeScript error lines (`file.ts(line,col): error TSxxxx: ...`), fall back to generic "error" lines. Show max 5 errors, indicate count of remaining. Target: under 500 tokens.
- `static summarizeTestFailures(rawOutput: string): string` — Extract Jest/Vitest failure markers (bullet chars), Jest summary line (`Tests: N failed...`), Mocha count (`N failing`). Show max 5 failures, indicate remaining. Fall back to lines containing FAIL/FAILED.
- `static summarizeLintErrors(rawOutput: string): string` — Extract ESLint format (`line:col  error  rule-name`), count affected files. Show max 5, indicate remaining.
- `static buildDigest(verificationResults: VerificationResult[]): string` — Collect summaries from all failed results into `[TYPE] summary` sections. Hard-cap output at 2000 chars (well under 500 tokens) with truncation notice.

All methods are synchronous (string manipulation only, no I/O). Follow the exact patterns from the research code examples.
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify all types compile correctly. Verify the new file exists with `ls src/orchestrator/summarizer.ts`.
  </verify>
  <done>
    types.ts contains VerificationError, VerificationResult, RetryConfig, RetryResult interfaces. summarizer.ts exports ErrorSummarizer with 4 static methods. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create RetryOrchestrator with outer retry loop</name>
  <files>
    src/orchestrator/retry.ts
  </files>
  <action>
**Create `src/orchestrator/retry.ts`** with the RetryOrchestrator class:

```typescript
import pino from 'pino';
import { AgentSession, SessionConfig } from './session.js';
import { SessionResult, RetryConfig, RetryResult, VerificationResult } from '../types.js';
import { ErrorSummarizer } from './summarizer.js';
```

**Constructor:** Accept `SessionConfig` and optional `RetryConfig` (default `{ maxRetries: 3 }`). Store both.

**`async run(originalTask: string, logger?: pino.Logger): Promise<RetryResult>`:**

1. Loop from `attempt = 1` to `maxRetries`:
   a. Build message: if attempt 1, use `originalTask` as-is. For subsequent attempts, call `this.buildRetryMessage(originalTask, attempt, verificationResults)`.
   b. Create a **new** `AgentSession(this.config)` — fresh session per attempt (CRITICAL: never reuse).
   c. Call `session.start()`.
   d. Call `session.run(message, logger)` in try/finally to ensure `session.stop()` always runs.
   e. Push sessionResult to array.
   f. If `sessionResult.status !== 'success'`, return immediately with `finalStatus` matching the session status. Do NOT retry timeout, turn_limit, or failed sessions.
   g. If no verifier configured (`!this.retryConfig.verifier`), return `{ finalStatus: 'success', ... }`.
   h. Run `this.retryConfig.verifier(this.config.workspaceDir)`.
   i. Push verificationResult. If `passed`, return success.
   j. Log warning with attempt number and error count.
   k. Continue loop (next attempt will build retry message with error context).
2. After loop exhausted: return `{ finalStatus: 'max_retries_exhausted', ... }`.

**`private buildRetryMessage(originalTask, attempt, priorResults): string`:**

1. Filter `priorResults` to failed results only.
2. Call `ErrorSummarizer.buildDigest(failedResults)` to get error digest.
3. Return structured message: original task first, then `---` separator, then `PREVIOUS ATTEMPT {N} FAILED VERIFICATION:`, then error digest, then `---`, then `Fix the issues above and complete the original task.`

Key design decisions:
- Session-level failures (timeout, turn_limit, failed) are terminal — do NOT retry.
- Only retry when session succeeds but verification fails.
- Original task is ALWAYS first in the message (primary directive).
- Error digest is secondary information after separator.
- No backoff delay between retries (verification failures are not transient).
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify compilation. Verify the file exports RetryOrchestrator: `grep 'export class RetryOrchestrator' src/orchestrator/retry.ts`.
  </verify>
  <done>
    retry.ts exports RetryOrchestrator with run() method implementing the outer retry loop. Fresh AgentSession per attempt. Session-level failures stop retrying. Verification failures trigger retry with error digest. Max retries enforced. TypeScript compiles.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `src/types.ts` contains VerificationError, VerificationResult, RetryConfig, RetryResult
3. `src/orchestrator/summarizer.ts` exports ErrorSummarizer with summarizeBuildErrors, summarizeTestFailures, summarizeLintErrors, buildDigest
4. `src/orchestrator/retry.ts` exports RetryOrchestrator with run() and buildRetryMessage()
5. RetryOrchestrator creates new AgentSession per attempt (grep confirms `new AgentSession`)
</verification>

<success_criteria>
- All three files exist and compile
- RetryOrchestrator implements outer retry loop distinct from API-level retry in agent.ts
- ErrorSummarizer extracts key error lines via regex, caps output at 2000 chars
- Type system connects VerificationResult to both summarizer and retry orchestrator
- No new dependencies added (pure TypeScript)
</success_criteria>

<output>
After completion, create `.planning/phases/04-retry-context-engineering/04-01-SUMMARY.md`
</output>
