---
phase: 03-agent-tool-access
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/orchestrator/session.ts
autonomous: true

must_haves:
  truths:
    - "Agent can read any file in workspace via read_file tool"
    - "Agent can edit files using str_replace with unique match validation"
    - "Agent can create new files via edit_file create command"
    - "Agent can run git status, diff, add, and commit (but not push)"
    - "Agent can search files with grep tool using ripgrep"
    - "Agent can run allowlisted bash commands (cat, head, tail, find, wc) but not arbitrary commands"
    - "Tool attempts outside allowlist are rejected with clear error"
    - "Path traversal outside workspace is blocked"
    - "Access to .git/hooks is denied"
  artifacts:
    - path: "src/orchestrator/session.ts"
      provides: "All tool implementations (edit_file, git_operation, grep, bash_command)"
      contains: "edit_file"
    - path: "package.json"
      provides: "write-file-atomic dependency"
      contains: "write-file-atomic"
  key_links:
    - from: "src/orchestrator/session.ts"
      to: "write-file-atomic"
      via: "import for atomic file writes in edit_file tool"
      pattern: "writeFileAtomic"
    - from: "src/orchestrator/session.ts executeTool"
      to: "src/orchestrator/container.ts exec"
      via: "container.exec with array-based commands"
      pattern: "this\\.container\\.exec\\("
---

<objective>
Implement all safe tool access for the agent: edit_file (str_replace + create), git_operation (status/diff/add/commit with --no-verify), grep (ripgrep), and bash_command (allowlisted cat/head/tail/find/wc). Replace unrestricted execute_bash with secure alternatives.

Purpose: Enable the agent to safely read, edit, search, and perform git operations within the workspace while preventing command injection, path traversal, and git hook privilege escalation.

Output: Updated session.ts with new TOOLS array and executeTool handlers; write-file-atomic dependency installed.
</objective>

<execution_context>
@/Users/kiruba/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kiruba/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-agent-tool-access/03-RESEARCH.md

# Prior phase context (tool routing pattern, session architecture)
@.planning/phases/01-foundation-security/01-04-SUMMARY.md

# Source files to modify
@src/orchestrator/session.ts
@src/orchestrator/container.ts
@src/types.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependency and harden path validation</name>
  <files>package.json, src/orchestrator/session.ts</files>
  <action>
1. Install write-file-atomic:
   ```bash
   npm install write-file-atomic
   npm install --save-dev @types/tmp
   ```
   Note: @types/tmp may not be needed if write-file-atomic has its own types. Check and only install what's needed.

2. In src/orchestrator/session.ts, enhance the existing `validatePath` method with three additional defense layers (keep existing resolve + startsWith check):
   - Reject null bytes: `if (inputPath.includes('\0'))` throw error
   - Block .git/hooks access: check if relative path starts with `.git/hooks`
   - Block node_modules/.bin access: check if relative path contains `node_modules/.bin`

   Use `path.relative(this.workspaceDir, resolved)` to get the relative path for pattern checks.

3. Add import for `write-file-atomic` at top of session.ts:
   ```typescript
   import writeFileAtomic from 'write-file-atomic';
   ```
   Also add `import * as fs from 'fs/promises';` if not already present.

Do NOT yet modify the TOOLS array or executeTool - that's Task 2 and Task 3.
  </action>
  <verify>
- `npm ls write-file-atomic` shows the package installed
- TypeScript compiles: `npx tsc --noEmit`
- validatePath rejects: paths with null bytes, paths to .git/hooks/*, paths outside workspace
  </verify>
  <done>write-file-atomic installed, validatePath blocks null bytes + .git/hooks + node_modules/.bin + path traversal</done>
</task>

<task type="auto">
  <name>Task 2: Implement edit_file, git_operation, and grep tools</name>
  <files>src/orchestrator/session.ts</files>
  <action>
1. Replace the TOOLS array with the new tool definitions. Keep `read_file` and `list_files` as-is. Remove `execute_bash`. Add these new tools:

   **edit_file tool:**
   ```typescript
   {
     name: 'edit_file',
     description: 'Edit a file using string replacement, or create a new file',
     input_schema: {
       type: 'object',
       properties: {
         command: {
           type: 'string',
           enum: ['str_replace', 'create'],
           description: 'Edit command: str_replace to edit existing, create to make new file'
         },
         path: { type: 'string', description: 'File path relative to workspace' },
         old_str: { type: 'string', description: 'Exact text to replace (str_replace only)' },
         new_str: { type: 'string', description: 'New text to insert (str_replace only)' },
         content: { type: 'string', description: 'File content (create only)' }
       },
       required: ['command', 'path']
     }
   }
   ```

   **git_operation tool:**
   ```typescript
   {
     name: 'git_operation',
     description: 'Execute safe Git operations: status, diff, add, commit. Push is not allowed.',
     input_schema: {
       type: 'object',
       properties: {
         operation: {
           type: 'string',
           enum: ['status', 'diff', 'add', 'commit'],
           description: 'Git operation to perform'
         },
         args: {
           type: 'array',
           items: { type: 'string' },
           description: 'Arguments for the operation (e.g., file paths for add, -m "message" for commit)'
         }
       },
       required: ['operation']
     }
   }
   ```

   **grep tool:**
   ```typescript
   {
     name: 'grep',
     description: 'Search for patterns in files using ripgrep',
     input_schema: {
       type: 'object',
       properties: {
         pattern: { type: 'string', description: 'Search pattern (regex supported)' },
         path: { type: 'string', description: 'Path to search relative to workspace (default: workspace root)' },
         case_insensitive: { type: 'boolean', description: 'Case-insensitive search (default: false)' },
         context_lines: { type: 'number', description: 'Lines of context around matches (default: 0)' }
       },
       required: ['pattern']
     }
   }
   ```

2. Implement the edit_file handler in executeTool:
   - For `str_replace`: Read file via container.exec(['cat', safePath]), validate unique match (count occurrences of old_str), replace, write atomically via writeFileAtomic on host filesystem. Return error with line numbers if multiple matches. Return error if old_str not found.
   - For `create`: Validate path, check file does NOT already exist (use fs.access), write content atomically via writeFileAtomic. Return error if file already exists (tell Claude to use str_replace instead).
   - IMPORTANT: Read via container (cat), write via host filesystem (writeFileAtomic). This is because container rootfs is read-only but workspace is bind-mounted at same absolute path.

3. Implement git_operation handler in executeTool:
   - Use absolute path `/usr/bin/git` to prevent PATH manipulation
   - For `status`: `[gitPath, '-C', workspaceDir, 'status', '--porcelain']`
   - For `diff`: `[gitPath, '-C', workspaceDir, 'diff', ...args]`
   - For `add`: Validate each path in args via validatePath, then `[gitPath, '-C', workspaceDir, 'add', '--', ...validatedPaths]`
   - For `commit`: `[gitPath, '-C', workspaceDir, 'commit', '--no-verify', ...args]` (CRITICAL: --no-verify prevents hook execution)
   - Handle git-specific exit codes: status returns 0 for clean, diff returns 0 for no differences
   - Return `(no changes)` or `(no differences)` for empty results

4. Implement grep handler in executeTool:
   - Use absolute path `/usr/bin/rg` to prevent PATH manipulation
   - Build command array: `[rgPath, '--color', 'never', '--no-heading', '--with-filename', '--line-number']`
   - Add `-i` if case_insensitive, add `-C N` if context_lines > 0
   - Use `--` separator before pattern to prevent flag injection
   - Validate path if provided
   - Handle exit codes: 0 = matches, 1 = no matches (return "(no matches found)"), 2+ = error

All command construction MUST use arrays (no string concatenation, no bash -c). This prevents shell metacharacter injection.
  </action>
  <verify>
- TypeScript compiles: `npx tsc --noEmit`
- TOOLS array has 5 tools: read_file, edit_file, git_operation, grep, list_files
- No `execute_bash` tool remains in the TOOLS array
- executeTool switch handles: read_file, edit_file, git_operation, grep, list_files
  </verify>
  <done>edit_file (str_replace + create), git_operation (status/diff/add/commit --no-verify), and grep tools implemented with array-based commands and absolute paths</done>
</task>

<task type="auto">
  <name>Task 3: Implement bash_command allowlist tool</name>
  <files>src/orchestrator/session.ts</files>
  <action>
1. Add the bash_command tool definition to the TOOLS array:
   ```typescript
   {
     name: 'bash_command',
     description: 'Run an allowlisted bash command. Allowed: cat, head, tail, find, wc. Use grep tool for searching.',
     input_schema: {
       type: 'object',
       properties: {
         command: {
           type: 'string',
           enum: ['cat', 'head', 'tail', 'find', 'wc'],
           description: 'Command to run'
         },
         args: {
           type: 'array',
           items: { type: 'string' },
           description: 'Arguments for the command'
         }
       },
       required: ['command']
     }
   }
   ```

2. Define a COMMAND_PATHS constant at module level (outside the class) mapping allowlisted commands to absolute paths:
   ```typescript
   const COMMAND_PATHS: Record<string, string> = {
     'cat': '/bin/cat',
     'head': '/usr/bin/head',
     'tail': '/usr/bin/tail',
     'find': '/usr/bin/find',
     'wc': '/usr/bin/wc'
   };
   ```
   Note: Alpine Linux paths may differ. Use `/bin/cat` for cat (it's in /bin on Alpine), and `/usr/bin/` for others. The container will validate at runtime.

3. Implement bash_command handler in executeTool:
   - Look up command in COMMAND_PATHS. If not found, return clear error: "Command not allowed. Allowed commands: cat, head, tail, find, wc"
   - Validate any file path arguments using validatePath (iterate args, validate those that look like paths)
   - Build command array: `[absolutePath, ...args]` (no bash -c, no shell interpretation)
   - Execute via container.exec with 30s timeout
   - Return stdout + stderr, or error message

4. Remove the old `execute_bash` case from executeTool switch statement entirely. It should no longer exist.

5. Verify the complete executeTool switch now handles exactly these cases:
   - read_file (existing, unchanged)
   - edit_file (new)
   - git_operation (new)
   - grep (new)
   - bash_command (new)
   - list_files (existing, unchanged)
   - default: "Unknown tool: {name}"
  </action>
  <verify>
- TypeScript compiles: `npx tsc --noEmit`
- TOOLS array has exactly 6 tools: read_file, edit_file, git_operation, grep, list_files, bash_command
- No reference to `execute_bash` anywhere in session.ts
- `grep -r "execute_bash" src/` returns no matches in session.ts
- COMMAND_PATHS uses absolute paths for all allowlisted commands
  </verify>
  <done>bash_command allowlist implemented with absolute paths, execute_bash completely removed, all 6 tools defined and routed</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsc --noEmit` passes (TypeScript compiles)
2. No reference to `execute_bash` in src/orchestrator/session.ts
3. TOOLS array contains exactly: read_file, edit_file, git_operation, grep, list_files, bash_command
4. validatePath blocks: null bytes, .git/hooks paths, paths outside workspace
5. edit_file uses writeFileAtomic for atomic writes on host filesystem
6. git commit uses --no-verify flag
7. All commands use absolute paths (no bare command names)
8. All commands use array construction (no bash -c, no string concatenation)
</verification>

<success_criteria>
- write-file-atomic installed and importable
- 6 tools defined in TOOLS array (no execute_bash)
- edit_file handles str_replace (with unique match validation) and create
- git_operation handles status, diff, add, commit (with --no-verify)
- grep uses ripgrep with safe flag handling
- bash_command allows only cat, head, tail, find, wc via absolute paths
- Path validation blocks null bytes, .git/hooks, and traversal outside workspace
- All commands use array-based construction (no shell interpretation)
</success_criteria>

<output>
After completion, create `.planning/phases/03-agent-tool-access/03-01-SUMMARY.md`
</output>
