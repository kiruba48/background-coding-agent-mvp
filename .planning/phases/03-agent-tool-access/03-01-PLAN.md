---
phase: 03-agent-tool-access
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/orchestrator/session.ts
autonomous: true

must_haves:
  truths:
    - "Agent can read any file in workspace via read_file tool"
    - "Agent can edit files using str_replace with unique match validation"
    - "Agent can create new files via edit_file create command"
    - "Agent can run git status, diff, add, and commit (but not push)"
    - "Agent can search files with grep tool using ripgrep"
    - "Agent can run allowlisted bash commands (cat, head, tail, find, wc) but not arbitrary commands"
    - "Tool attempts outside allowlist are rejected with clear error"
    - "Path traversal outside workspace is blocked"
    - "Access to .git/hooks is denied"
    - "Git operations execute on host to avoid container permission issues with .git/"
    - "Edit tool writes files readable by container user (0o644 permissions)"
  artifacts:
    - path: "src/orchestrator/session.ts"
      provides: "All tool implementations (edit_file, git_operation, grep, bash_command)"
      contains: "edit_file"
    - path: "package.json"
      provides: "write-file-atomic dependency"
      contains: "write-file-atomic"
  key_links:
    - from: "src/orchestrator/session.ts"
      to: "write-file-atomic"
      via: "import for atomic file writes in edit_file tool"
      pattern: "writeFileAtomic"
    - from: "src/orchestrator/session.ts executeTool"
      to: "src/orchestrator/container.ts exec"
      via: "container.exec with array-based commands for read-only tools"
      pattern: "this\\.container\\.exec\\("
    - from: "src/orchestrator/session.ts executeTool git_operation"
      to: "child_process.execFile"
      via: "host-side git execution to avoid .git/ permission issues"
      pattern: "execFileAsync"
---

<objective>
Implement all safe tool access for the agent: edit_file (str_replace + create), git_operation (status/diff/add/commit with --no-verify), grep (ripgrep), and bash_command (allowlisted cat/head/tail/find/wc). Replace unrestricted execute_bash with secure alternatives.

Purpose: Enable the agent to safely read, edit, search, and perform git operations within the workspace while preventing command injection, path traversal, and git hook privilege escalation.

Output: Updated session.ts with new TOOLS array and executeTool handlers; write-file-atomic dependency installed.
</objective>

<execution_context>
@/Users/kiruba/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kiruba/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-agent-tool-access/03-RESEARCH.md

# Prior phase context (tool routing pattern, session architecture)
@.planning/phases/01-foundation-security/01-04-SUMMARY.md

# Source files to modify
@src/orchestrator/session.ts
@src/orchestrator/container.ts
@src/types.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependency and harden path validation</name>
  <files>package.json, src/orchestrator/session.ts</files>
  <action>
1. Install write-file-atomic:
   ```bash
   npm install write-file-atomic
   npm install --save-dev @types/tmp
   ```
   Note: @types/tmp may not be needed if write-file-atomic has its own types. Check and only install what's needed.

2. In src/orchestrator/session.ts, enhance the existing `validatePath` method with three additional defense layers (keep existing resolve + startsWith check):
   - Reject null bytes: `if (inputPath.includes('\0'))` throw error
   - Block .git/hooks access: check if relative path starts with `.git/hooks`
   - Block node_modules/.bin access: check if relative path contains `node_modules/.bin`

   Use `path.relative(this.workspaceDir, resolved)` to get the relative path for pattern checks.

3. Add imports at top of session.ts:
   ```typescript
   import writeFileAtomic from 'write-file-atomic';
   import * as fs from 'fs/promises';
   import { execFile } from 'child_process';
   import { promisify } from 'util';

   const execFileAsync = promisify(execFile);
   ```

Do NOT yet modify the TOOLS array or executeTool - that's Task 2, 3, and 4.
  </action>
  <verify>
- `npm ls write-file-atomic` shows the package installed
- TypeScript compiles: `npx tsc --noEmit`
- validatePath rejects: paths with null bytes, paths to .git/hooks/*, paths outside workspace
  </verify>
  <done>write-file-atomic installed, validatePath blocks null bytes + .git/hooks + node_modules/.bin + path traversal</done>
</task>

<task type="auto">
  <name>Task 2: Implement edit_file and grep tools</name>
  <files>src/orchestrator/session.ts</files>
  <action>
1. Replace the TOOLS array with the new tool definitions. Keep `read_file` and `list_files` as-is. Remove `execute_bash`. Add these new tools:

   **edit_file tool:**
   ```typescript
   {
     name: 'edit_file',
     description: 'Edit a file using string replacement, or create a new file',
     input_schema: {
       type: 'object',
       properties: {
         command: {
           type: 'string',
           enum: ['str_replace', 'create'],
           description: 'Edit command: str_replace to edit existing, create to make new file'
         },
         path: { type: 'string', description: 'File path relative to workspace' },
         old_str: { type: 'string', description: 'Exact text to replace (str_replace only)' },
         new_str: { type: 'string', description: 'New text to insert (str_replace only)' },
         content: { type: 'string', description: 'File content (create only)' }
       },
       required: ['command', 'path']
     }
   }
   ```

   **grep tool:**
   ```typescript
   {
     name: 'grep',
     description: 'Search for patterns in files using ripgrep',
     input_schema: {
       type: 'object',
       properties: {
         pattern: { type: 'string', description: 'Search pattern (regex supported)' },
         path: { type: 'string', description: 'Path to search relative to workspace (default: workspace root)' },
         case_insensitive: { type: 'boolean', description: 'Case-insensitive search (default: false)' },
         context_lines: { type: 'number', description: 'Lines of context around matches (default: 0)' }
       },
       required: ['pattern']
     }
   }
   ```

2. Implement the edit_file handler in executeTool:

   **For `str_replace`:**
   - Read file via container.exec(['cat', safePath])
   - Count occurrences: `content.split(old_str).length - 1` (this works correctly for counting)
   - If 0 matches: return error "old_str not found in file"
   - If >1 matches: find match positions using indexOf loop on the FULL content string (NOT per-line includes), then map byte offsets to line numbers:
     ```typescript
     // IMPORTANT: Do NOT use line.includes(old_str) — it fails for multi-line old_str
     let pos = 0;
     const matchPositions: number[] = [];
     while ((pos = content.indexOf(old_str, pos)) !== -1) {
       const lineNum = content.substring(0, pos).split('\n').length;
       matchPositions.push(lineNum);
       pos += old_str.length;
     }
     return `Error: old_str found ${occurrences} times at lines ${matchPositions.join(', ')}. Provide more context for unique match.`;
     ```
   - If exactly 1 match: `content.replace(old_str, new_str)`, write atomically via writeFileAtomic on host filesystem
   - Write with mode 0o644 so container user (UID 1001) can still read:
     ```typescript
     await writeFileAtomic(safePath, newContent, { encoding: 'utf-8', mode: 0o644 });
     ```
   - NOTE: Do NOT set chown option — files should be owned by the host process user. The container reads them via 'other' read permission (644). This avoids the ownership mismatch pitfall.

   **For `create`:**
   - Validate path via validatePath
   - Use writeFileAtomic with the `{ flag: 'wx' }` option to atomically fail if file already exists (avoids TOCTOU race between check and write):
     ```typescript
     try {
       await writeFileAtomic(safePath, content, { encoding: 'utf-8', mode: 0o644, flag: 'wx' });
       return 'File created successfully';
     } catch (err) {
       if (err.code === 'EEXIST') {
         return 'Error: File already exists. Use str_replace to edit existing files.';
       }
       throw err;
     }
     ```
   - NOTE: writeFileAtomic may not support the `flag` option directly. If it doesn't, fall back to: first check with `fs.access(safePath, fs.constants.F_OK)` — if file exists return error, then write. This is acceptable because in our single-threaded orchestrator, TOCTOU is extremely unlikely.

   **IMPORTANT asymmetry:** Read via container (cat), write via host filesystem (writeFileAtomic). This is because container rootfs is read-only but workspace is bind-mounted at same absolute path on the host.

3. Implement grep handler in executeTool:
   - Use absolute path `/usr/bin/rg` (verified in Docker image)
   - Build command array: `['/usr/bin/rg', '--color', 'never', '--no-heading', '--with-filename', '--line-number']`
   - Add `-i` if case_insensitive, add `-C N` if context_lines > 0
   - Use `--` separator before pattern to prevent flag injection
   - Validate path if provided
   - Handle exit codes: 0 = matches, 1 = no matches (return "(no matches found)"), 2+ = error

All command construction MUST use arrays (no string concatenation, no bash -c). This prevents shell metacharacter injection.
  </action>
  <verify>
- TypeScript compiles: `npx tsc --noEmit`
- edit_file and grep tools defined in TOOLS array
- executeTool handles edit_file and grep cases
- Multi-line match reporting uses indexOf loop (NOT line.includes)
  </verify>
  <done>edit_file (str_replace with multi-line-safe match reporting + create with EEXIST check) and grep tools implemented</done>
</task>

<task type="auto">
  <name>Task 3: Implement git_operation tool on HOST</name>
  <files>src/orchestrator/session.ts</files>
  <action>
**CRITICAL ARCHITECTURE DECISION:** Git operations MUST execute on the HOST process (via child_process.execFile), NOT inside the container (via container.exec). Reason:

The workspace is bind-mounted into the container. Files are owned by the host user (e.g., UID 501 on macOS). The container runs as UID 1001 (agent user). Git operations like `git add` and `git commit` write to `.git/` (index, objects, refs). The container user (UID 1001) does NOT have write permission to the host-owned `.git/` directory. This would cause silent failures on Linux.

The fix: Run git commands on the host using Node.js `child_process.execFile`. This is consistent with how edit_file already writes via the host. Security is maintained through:
- Hardcoded operation enum (only status/diff/add/commit)
- Argument validation (allowed flags only)
- --no-verify on commit (prevents hook execution)
- Array-based command construction (prevents injection)
- Path validation for file arguments

1. Add the git_operation tool definition to the TOOLS array:
   ```typescript
   {
     name: 'git_operation',
     description: 'Execute safe Git operations: status, diff, add, commit. Push is not allowed.',
     input_schema: {
       type: 'object',
       properties: {
         operation: {
           type: 'string',
           enum: ['status', 'diff', 'add', 'commit'],
           description: 'Git operation to perform'
         },
         args: {
           type: 'array',
           items: { type: 'string' },
           description: 'Arguments for the operation (e.g., file paths for add, -m "message" for commit)'
         }
       },
       required: ['operation']
     }
   }
   ```

2. Define allowed git flags at module level:
   ```typescript
   const ALLOWED_GIT_DIFF_FLAGS = new Set([
     '--cached', '--staged', '--stat', '--name-only', '--name-status',
     '--shortstat', '--numstat', '--no-color'
   ]);
   const ALLOWED_GIT_COMMIT_FLAGS = new Set(['-m', '--message']);
   ```

3. Implement git_operation handler using execFileAsync (host-side execution):
   ```typescript
   case 'git_operation': {
     const operation = input.operation as string;
     const args = (input.args as string[]) || [];
     const gitPath = '/usr/bin/git'; // Use system git on host

     let command: string[];

     switch (operation) {
       case 'status':
         command = [gitPath, '-C', this.workspaceDir, 'status', '--porcelain'];
         break;

       case 'diff': {
         // Validate flags — only allow known-safe flags and file paths
         const diffArgs: string[] = [];
         for (const arg of args) {
           if (arg.startsWith('-')) {
             if (!ALLOWED_GIT_DIFF_FLAGS.has(arg)) {
               return `Error: Flag '${arg}' is not allowed for git diff. Allowed: ${[...ALLOWED_GIT_DIFF_FLAGS].join(', ')}`;
             }
             diffArgs.push(arg);
           } else {
             // File path — validate it
             try {
               this.validatePath(arg);
               diffArgs.push(arg);
             } catch (e) {
               return `Error: ${e instanceof Error ? e.message : 'Invalid path'}`;
             }
           }
         }
         command = [gitPath, '-C', this.workspaceDir, 'diff', ...diffArgs];
         break;
       }

       case 'add': {
         // All args must be validated file paths
         const validatedPaths: string[] = [];
         for (const arg of args) {
           try {
             validatedPaths.push(this.validatePath(arg));
           } catch (e) {
             return `Error: ${e instanceof Error ? e.message : 'Invalid path'}`;
           }
         }
         if (validatedPaths.length === 0) {
           return 'Error: git add requires at least one file path';
         }
         command = [gitPath, '-C', this.workspaceDir, 'add', '--', ...validatedPaths];
         break;
       }

       case 'commit': {
         // Only allow -m flag and its value
         const commitArgs: string[] = ['--no-verify']; // ALWAYS prevent hook execution
         let i = 0;
         while (i < args.length) {
           const arg = args[i];
           if (arg === '-m' || arg === '--message') {
             if (i + 1 >= args.length) {
               return 'Error: -m flag requires a message argument';
             }
             commitArgs.push(arg, args[i + 1]);
             i += 2;
           } else if (arg.startsWith('-')) {
             return `Error: Flag '${arg}' is not allowed for git commit. Allowed: -m, --message`;
           } else {
             // File path — validate it
             try {
               this.validatePath(arg);
               commitArgs.push(arg);
             } catch (e) {
               return `Error: ${e instanceof Error ? e.message : 'Invalid path'}`;
             }
             i++;
           }
         }
         command = [gitPath, '-C', this.workspaceDir, 'commit', ...commitArgs];
         break;
       }

       default:
         return `Error: Unknown git operation '${operation}'. Allowed: status, diff, add, commit`;
     }

     // Execute on HOST via execFileAsync (NOT container.exec)
     try {
       const { stdout, stderr } = await execFileAsync(command[0], command.slice(1), {
         cwd: this.workspaceDir,
         timeout: 30000
       });
       const output = (stdout + stderr).trim();
       return output || (operation === 'status' ? '(no changes)' : operation === 'diff' ? '(no differences)' : 'Done');
     } catch (err: any) {
       // execFile throws on non-zero exit code
       if (err.stdout || err.stderr) {
         return `Error: ${(err.stderr || err.stdout || '').trim()}`;
       }
       return `Error: ${err.message}`;
     }
   }
   ```

   **NOTE on git path:** The `gitPath` for host execution should use whichever git is available on the host, not the container's `/usr/bin/git`. Use just `'git'` and let PATH resolution find it, OR use a configurable path. Since execFileAsync does NOT use a shell, PATH resolution still works because Node.js child_process.execFile searches PATH by default. Simplest: use `'git'` as the command.

   Actually, revise: use `'git'` (not `/usr/bin/git`) for host-side execution since the host may have git at a different path than the container. The security comes from the hardcoded operation enum and flag validation, not from the absolute path.

4. Handle git-specific exit codes: status returns 0 for clean, diff returns 0 for no differences.
  </action>
  <verify>
- TypeScript compiles: `npx tsc --noEmit`
- git_operation defined in TOOLS array
- git_operation uses execFileAsync (NOT container.exec) for all operations
- git commit always includes --no-verify
- git diff only allows flags from ALLOWED_GIT_DIFF_FLAGS
- git commit only allows -m/--message flag
- git add validates all paths via validatePath
  </verify>
  <done>git_operation implemented on host via execFileAsync with flag validation and --no-verify, avoiding container permission issues</done>
</task>

<task type="auto">
  <name>Task 4: Implement bash_command allowlist tool</name>
  <files>src/orchestrator/session.ts</files>
  <action>
1. Add the bash_command tool definition to the TOOLS array:
   ```typescript
   {
     name: 'bash_command',
     description: 'Run an allowlisted bash command. Allowed: cat, head, tail, find, wc. Use grep tool for searching.',
     input_schema: {
       type: 'object',
       properties: {
         command: {
           type: 'string',
           enum: ['cat', 'head', 'tail', 'find', 'wc'],
           description: 'Command to run'
         },
         args: {
           type: 'array',
           items: { type: 'string' },
           description: 'Arguments for the command'
         }
       },
       required: ['command']
     }
   }
   ```

2. Define a COMMAND_PATHS constant at module level mapping allowlisted commands to their verified absolute paths in the Alpine container:
   ```typescript
   // Verified paths in agent-sandbox Alpine 3.18 image:
   // /bin/cat → BusyBox symlink
   // /usr/bin/head, /usr/bin/tail, /usr/bin/find, /usr/bin/wc → BusyBox symlinks
   const COMMAND_PATHS: Record<string, string> = {
     'cat': '/bin/cat',
     'head': '/usr/bin/head',
     'tail': '/usr/bin/tail',
     'find': '/usr/bin/find',
     'wc': '/usr/bin/wc'
   };
   ```

3. Implement bash_command handler in executeTool:
   - Look up command in COMMAND_PATHS. If not found, return clear error: "Command not allowed. Allowed commands: cat, head, tail, find, wc"
   - Validate any file path arguments using validatePath (iterate args, validate those that look like paths — i.e., don't start with `-`)
   - Build command array: `[absolutePath, ...args]` (no bash -c, no shell interpretation)
   - Execute via container.exec with 30s timeout
   - Return stdout + stderr, or error message

4. Remove the old `execute_bash` case from executeTool switch statement entirely. It should no longer exist.

5. Verify the complete executeTool switch now handles exactly these cases:
   - read_file (existing, unchanged)
   - edit_file (new — Task 2)
   - git_operation (new — Task 3, uses execFileAsync on host)
   - grep (new — Task 2, uses container.exec)
   - bash_command (new — this task, uses container.exec)
   - list_files (existing, unchanged)
   - default: "Unknown tool: {name}"
  </action>
  <verify>
- TypeScript compiles: `npx tsc --noEmit`
- TOOLS array has exactly 6 tools: read_file, edit_file, git_operation, grep, list_files, bash_command
- No reference to `execute_bash` anywhere in session.ts
- `grep -r "execute_bash" src/` returns no matches in session.ts
- COMMAND_PATHS uses verified absolute paths for all allowlisted commands
  </verify>
  <done>bash_command allowlist implemented with verified absolute paths, execute_bash completely removed, all 6 tools defined and routed</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsc --noEmit` passes (TypeScript compiles)
2. No reference to `execute_bash` in src/orchestrator/session.ts
3. TOOLS array contains exactly: read_file, edit_file, git_operation, grep, list_files, bash_command
4. validatePath blocks: null bytes, .git/hooks paths, paths outside workspace
5. edit_file uses writeFileAtomic for atomic writes on host filesystem with mode 0o644
6. edit_file create uses flag-based existence check (wx or fs.access) to prevent overwrite
7. edit_file multi-line match reporting uses indexOf loop (not line.includes)
8. git_operation runs on HOST via execFileAsync (NOT container.exec)
9. git commit uses --no-verify flag
10. git diff/commit validate args against allowed flag sets
11. All container commands use absolute paths (no bare command names)
12. All commands use array construction (no bash -c, no string concatenation)
</verification>

<success_criteria>
- write-file-atomic installed and importable
- 6 tools defined in TOOLS array (no execute_bash)
- edit_file handles str_replace (with multi-line-safe unique match validation) and create (with EEXIST handling)
- git_operation runs on host via execFileAsync with flag validation and --no-verify
- grep uses ripgrep (/usr/bin/rg) with safe flag handling via container.exec
- bash_command allows only cat, head, tail, find, wc via verified absolute paths
- Path validation blocks null bytes, .git/hooks, and traversal outside workspace
- All commands use array-based construction (no shell interpretation)
- File writes use mode 0o644 so container user can read host-written files
</success_criteria>

<output>
After completion, create `.planning/phases/03-agent-tool-access/03-01-SUMMARY.md`
</output>
