---
phase: 03-agent-tool-access
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/orchestrator/session.test.ts
autonomous: true

must_haves:
  truths:
    - "Edit tool rejects paths with null bytes"
    - "Edit tool rejects paths to .git/hooks"
    - "Edit tool rejects paths outside workspace"
    - "Edit str_replace fails gracefully when old_str not found"
    - "Edit str_replace fails gracefully when old_str matches multiple locations (including multi-line)"
    - "Edit str_replace succeeds when old_str matches exactly once"
    - "Edit create fails if file already exists"
    - "Git operation rejects unknown operations"
    - "Git commit uses --no-verify"
    - "Git diff rejects disallowed flags"
    - "Git commit rejects disallowed flags (e.g., --amend)"
    - "Git operations execute on host (not container)"
    - "Bash allowlist rejects disallowed commands"
    - "Bash allowlist accepts allowed commands (cat, head, tail, find, wc)"
    - "Ripgrep is available in the Docker container"
    - "Unknown tool names return clear error"
  artifacts:
    - path: "src/orchestrator/session.test.ts"
      provides: "Comprehensive tests for all Phase 3 tools"
      contains: "edit_file"
  key_links:
    - from: "src/orchestrator/session.test.ts"
      to: "src/orchestrator/session.ts executeTool"
      via: "Direct method testing via AgentSession"
      pattern: "executeTool|edit_file|git_operation|bash_command"
---

<objective>
Write comprehensive tests for all Phase 3 tool implementations: path validation hardening, edit_file (str_replace + create), git_operation (host-side execution with flag validation), grep, and bash_command allowlist. Tests must verify both happy paths and security rejection cases.

Purpose: Prove that tools work correctly AND that security boundaries hold (disallowed commands rejected, path traversal blocked, git hooks prevented, disallowed git flags rejected).

Output: Updated session.test.ts with unit and integration tests covering all new tool functionality.
</objective>

<execution_context>
@/Users/kiruba/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kiruba/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-agent-tool-access/03-RESEARCH.md
@.planning/phases/03-agent-tool-access/03-01-SUMMARY.md

# Source files to test against
@src/orchestrator/session.ts
@src/orchestrator/session.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write unit tests for path validation and edit_file tool</name>
  <files>src/orchestrator/session.test.ts</files>
  <action>
The existing session.test.ts uses real Docker + API calls (integration tests). Phase 3 tests should follow the same pattern where possible, but path validation and edit logic can be tested more directly.

**Approach:** Since executeTool is a private method on AgentSession, test it indirectly by:
1. Creating a test helper that exercises tools through a running session
2. OR extract testable logic into separate functions/methods

**Recommended approach:** Create a focused test file OR update the existing one. Use the existing pattern of creating a real container session and calling tools through it.

Write tests for:

**Path validation hardening (5 tests):**
- Null byte in path rejected: path containing `\0` returns error
- .git/hooks access denied: path `.git/hooks/pre-commit` returns error
- node_modules/.bin access denied: path `node_modules/.bin/something` returns error
- Path traversal blocked: path `../../etc/passwd` returns error
- Valid workspace path succeeds: path `src/test.txt` works normally

**edit_file str_replace (5 tests):**
- Successful single-line replacement: create a test file in workspace, call str_replace with unique old_str, verify file content changed
- Successful multi-line replacement: create a test file, call str_replace with old_str that spans multiple lines, verify correct replacement
- Non-existent old_str: call str_replace with text not in file, verify error message says "not found"
- Multiple matches with line numbers: create file with repeated text, call str_replace, verify error includes correct match count AND line numbers (tests the indexOf-based reporting, not per-line includes)
- Non-existent file: call str_replace on path that doesn't exist, verify error

**edit_file create (3 tests):**
- Successful create: call create with new filename and content, verify file exists with correct content
- File already exists: create a file, then try create again, verify error saying file already exists (tests the EEXIST / existence check)
- Create with path validation: try to create file at `../../evil.txt`, verify rejection

For testing, create temporary test files in the workspace directory before running tool calls. Clean up after.

The test pattern from the existing test file is:
```typescript
const session = new AgentSession({ workspaceDir: testDir });
await session.start();
// ... test tool calls via agent loop or direct method access
await session.stop();
```

Since executeTool is private, you have two options:
1. Use the agent loop with a specific prompt that triggers the tool (expensive, uses API credits)
2. Make executeTool accessible for testing by casting: `(session as any).executeTool('edit_file', { ... })`

Use option 2 (casting) for unit tests since it avoids API costs and is faster. Mark these as "Tool unit tests" to distinguish from E2E tests.

IMPORTANT: Before calling executeTool, you must call session.start() to initialize the container. Also manually set workspaceDir on the session instance via `(session as any).workspaceDir = testDir`.
  </action>
  <verify>
- Tests run: `npx tsx src/orchestrator/session.test.ts`
- All path validation tests pass (5 tests)
- All edit_file str_replace tests pass (5 tests, including multi-line)
- All edit_file create tests pass (3 tests)
  </verify>
  <done>13 tests for path validation and edit_file tool passing, covering single-line, multi-line, and security rejection cases</done>
</task>

<task type="auto">
  <name>Task 2: Write tests for git_operation, grep, and bash_command tools</name>
  <files>src/orchestrator/session.test.ts</files>
  <action>
Continue adding tests to session.test.ts:

**Precondition test (1 test):**
- Ripgrep available in container: start a session, run container.exec(['/usr/bin/rg', '--version']), verify it returns a version string. This catches the case where the Docker image doesn't have rg installed, providing a clear error instead of cryptic failures in grep tests.

**git_operation (6 tests):**
- git status works: initialize a git repo in test workspace, call git_operation status, verify it returns porcelain output
- git diff works: modify a tracked file, call git_operation diff, verify diff output
- git add + commit works: add and commit a file, verify commit succeeds
- Unknown operation rejected: call git_operation with operation "push", verify error
- git diff rejects disallowed flag: call git_operation diff with args ['--output=/tmp/evil'], verify error listing allowed flags
- git commit rejects disallowed flag: call git_operation commit with args ['--amend', '-m', 'evil'], verify error listing allowed flags

**IMPORTANT for git tests:** git_operation now runs on the HOST via execFileAsync (not container.exec). This means:
- Git must be available on the host machine (it should be, since this is a git repo)
- Initialize the test workspace as a git repo on the host: `git -C testDir init`, `git -C testDir config user.email "test@test.com"`, `git -C testDir config user.name "Test"`
- The test verifies that host-side execution works correctly (no container permission issues)

**grep (3 tests):**
- Pattern found: create a test file with known content, grep for a pattern, verify matches returned with filenames and line numbers
- Pattern not found: grep for pattern not in any file, verify "(no matches found)" returned
- Case insensitive: create file with "Hello", grep for "hello" with case_insensitive: true, verify match

**bash_command (4 tests):**
- Allowed command works (cat): create a test file, call bash_command cat with file path, verify content returned
- Allowed command works (wc): create a test file, call bash_command wc, verify line count
- Disallowed command rejected: call bash_command with command "rm", verify error message lists allowed commands
- Disallowed command rejected (bash): call bash_command with command "bash", verify rejection

**Unknown tool (1 test):**
- Call executeTool with name "nonexistent_tool", verify "Unknown tool" error returned

**Test setup:**
- Create a temporary test directory for each test group
- Initialize git repo in the test directory for git tests
- Clean up after tests

Add a test script to package.json if one doesn't exist:
```json
"test:tools": "npx tsx src/orchestrator/session.test.ts"
```
Or update the existing test:session script if it already runs this file.
  </action>
  <verify>
- Precondition test passes (rg available) (1 test)
- All git_operation tests pass (6 tests, including flag validation)
- All grep tests pass (3 tests)
- All bash_command tests pass (4 tests)
- Unknown tool test passes (1 test)
- Full test suite: `npx tsx src/orchestrator/session.test.ts` passes
  </verify>
  <done>15 additional tests for precondition, git_operation (with flag validation), grep, bash_command, and unknown tool passing. Total: ~28 tests covering all Phase 3 tool functionality including security boundaries</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsx src/orchestrator/session.test.ts` passes all tests
2. Security rejection tests verify: path traversal blocked, null bytes rejected, .git/hooks denied, disallowed commands rejected, disallowed git flags rejected
3. Happy path tests verify: edit succeeds (single-line and multi-line), git operations work (on host), grep finds patterns, allowlisted commands execute
4. Precondition test confirms rg is in Docker image
5. Git flag validation tests confirm --output, --amend, etc. are rejected
6. Multi-line str_replace match reporting test confirms correct line numbers
7. No flaky tests (deterministic file creation and validation)
</verification>

<success_criteria>
- All new tests pass on a single run
- Path validation tests cover: null bytes, .git/hooks, traversal, valid paths
- edit_file tests cover: str_replace success (single-line + multi-line), str_replace failures (not found, multiple matches with correct line numbers), create success, create failure (already exists)
- git_operation tests cover: status, diff, add+commit, unknown operation rejection, disallowed diff flag rejection, disallowed commit flag rejection
- grep tests cover: match found, no match, case insensitive
- bash_command tests cover: allowed commands work, disallowed commands rejected
- Precondition test verifies rg availability in container
- Unknown tool test verifies clear error message
</success_criteria>

<output>
After completion, create `.planning/phases/03-agent-tool-access/03-02-SUMMARY.md`
</output>
